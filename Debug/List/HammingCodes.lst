###############################################################################
#
# IAR C/C++ Compiler V7.10.6.1378 for Atmel AVR           24/May/2023  08:20:26
# Copyright 1996-2018 IAR Systems AB.
#
#    Source file  =  
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\src\HammingCodes.cpp
#    Command line =  
#        -f C:\Users\Admin\AppData\Local\Temp\EWCFA6.tmp
#        (--string_literals_in_flash
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\src\HammingCodes.cpp
#        --cpu=m128a -ms -o
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\Obj -lC
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\List -lB
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\List -y
#        --initializers_in_flash --root_variables --debug
#        -DENABLE_BIT_DEFINITIONS -e -I
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Modbus\ -I
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\include\
#        --eeprom_size 4096 --dlib --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -Ohz
#        --eec++)
#    Locale       =  Russian_RUS.1251
#    List file    =  
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\List\HammingCodes.lst
#    Object file  =  
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\Obj\HammingCodes.r90
#
###############################################################################

D:\Projects\CurrentProjects\CautoProjects\PSS48Color\src\HammingCodes.cpp
      1          
      2          //-----------------------------------------------------------------------------------------------------
      3          //  Based on    : https://github.com/Minho-Cha/8bit-Hamming-Code
      4          //  Source      : FileName.cpp
      5          //  Created     : 01.06.2022
      6          //  Author      : Alexandr Volvenkin
      7          //  email       : aav-36@mail.ru
      8          //  GitHub      : https://github.com/AlexandrVolvenkin
      9          //-----------------------------------------------------------------------------------------------------
     10          #include "HammingCodes.h"
     11          #include "Crc.h"
     12          
     13          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment NEAR_Z, align 1, keep-with-next, root
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     14          uint8_t CHammingCodes::m_uiErrorCode;
   \                     ??m_uiErrorCode:
   \   00000000                      DS8 1
     15          
     16          ////-----------------------------------------------------------------------------------------------------
     17          //CHammingCodes::CHammingCodes()
     18          //{
     19          //    //ctor
     20          //}
     21          //
     22          ////-----------------------------------------------------------------------------------------------------
     23          //CHammingCodes::~CHammingCodes()
     24          //{
     25          //    //dtor
     26          //}
     27          
     28          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
     29          uint8_t CHammingCodes::getEvenParityforTx(uint8_t data) //?? ???
   \                     ??getEvenParityforTx:
     30          {
   \   00000000   2F30               MOV     R19, R16
     31              uint8_t parity = 0;
   \   00000002   E050               LDI     R21, 0
     32              for (int i = 0; i < 8; i++)
   \   00000004   E0E0               LDI     R30, 0
   \   00000006   E0F0               LDI     R31, 0
   \   00000008   E028               LDI     R18, 8
     33              {
     34                  parity ^= (data >> i) & 0x01;
   \                     ??getEvenParityforTx_1:
   \   0000000A   2F03               MOV     R16, R19
   \   0000000C   E010               LDI     R17, 0
   \   0000000E   2F4E               MOV     R20, R30
   \   00000010   ........           CALL    ?SS_SHR_L02
   \   00000014   7001               ANDI    R16, 0x01
   \   00000016   2750               EOR     R21, R16
     35              }
   \   00000018   9631               ADIW    R31:R30, 1
   \   0000001A   952A               DEC     R18
   \   0000001C   F7B1               BRNE    ??getEvenParityforTx_1
     36          
     37              return !parity;
   \   0000001E   2355               TST     R21
   \   00000020   F409               BRNE    ??getEvenParityforTx_2
   \   00000022   ....               RJMP    ?Subroutine9
   \                     ??getEvenParityforTx_2:
   \   00000024   ....               RJMP    ?Subroutine10
     38          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine9:
   \   00000000   E001               LDI     R16, 1
   \   00000002   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine10:
   \   00000000   E000               LDI     R16, 0
   \   00000002   9508               RET
     39          
     40          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
     41          uint8_t CHammingCodes::getEvenParityforRx(uint16_t data) //?? ???
   \                     ??getEvenParityforRx:
     42          {
   \   00000000   01B8               MOVW    R23:R22, R17:R16
     43              uint8_t parity = 0;
   \   00000002   E030               LDI     R19, 0
     44              for (int i = 0; i < 12; i++)
   \   00000004   E0E0               LDI     R30, 0
   \   00000006   E0F0               LDI     R31, 0
   \   00000008   E02C               LDI     R18, 12
     45              {
     46                  parity ^= (data >> i) & 0x01;
   \                     ??getEvenParityforRx_1:
   \   0000000A   2F4E               MOV     R20, R30
   \   0000000C   018B               MOVW    R17:R16, R23:R22
   \   0000000E   ........           CALL    ?US_SHR_L02
   \   00000012   7001               ANDI    R16, 0x01
   \   00000014   2730               EOR     R19, R16
     47              }
   \   00000016   9631               ADIW    R31:R30, 1
   \   00000018   952A               DEC     R18
   \   0000001A   F7B9               BRNE    ??getEvenParityforRx_1
     48          
     49              return !parity;
   \   0000001C   2333               TST     R19
   \   0000001E   F409               BRNE    ??getEvenParityforRx_2
   \   00000020   ....               RJMP    ?Subroutine9
   \                     ??getEvenParityforRx_2:
   \   00000022   ....               RJMP    ?Subroutine10
     50          }
     51          
     52          //-----------------------------------------------------------------------------------------------------
     53          // Get Hamming code

   \                                 In  segment CODE, align 2, keep-with-next
     54          uint16_t CHammingCodes::enHamming(uint8_t data)
   \                     ??enHamming:
     55          {
   \   00000000   938A               ST      -Y, R24
   \   00000002   2F80               MOV     R24, R16
     56              uint16_t hamming = 0;
     57          
     58              // Set Data
     59              hamming = (data & BLOCK2) << BLOCK2_SHIFT;  //0b1111 0000 0000
     60              hamming |= (data & BLOCK1) << BLOCK1_SHIFT;  //0b0000 0111 0000
     61              hamming |= (data & BLOCK0) << BLOCK0_SHIFT;  //0b0000 0000 0100
     62          
     63              // Set Parity
     64              hamming |= getEvenParityforTx(data & P3_POSI_8) << P3_BIT; // 0b1111 0000
   \   00000004   7F00               ANDI    R16, 0xF0
   \   00000006   ....               RCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_7:
   \   00000008   2E30               MOV     R3, R16
     65              hamming |= getEvenParityforTx(data & P2_POSI_8) << P2_BIT; // 0b1000 1110
   \   0000000A   2F08               MOV     R16, R24
   \   0000000C   780E               ANDI    R16, 0x8E
   \   0000000E   ....               RCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_6:
   \   00000010   2E20               MOV     R2, R16
     66              hamming |= getEvenParityforTx(data & P1_POSI_8) << P1_BIT; // 0b0110 1101
   \   00000012   2F08               MOV     R16, R24
   \   00000014   760D               ANDI    R16, 0x6D
   \   00000016   ....               RCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_5:
   \   00000018   2F10               MOV     R17, R16
     67              hamming |= getEvenParityforTx(data & P0_POSI_8) << P0_BIT; // 0b0101 1011
     68          
     69              return hamming;
   \   0000001A   E100               LDI     R16, 16
   \   0000001C   9F80               MUL     R24, R16
   \   0000001E   2D71               MOV     R23, R1
   \   00000020   E008               LDI     R16, 8
   \   00000022   9F80               MUL     R24, R16
   \   00000024   E700               LDI     R16, 112
   \   00000026   2200               AND     R0, R16
   \   00000028   2D60               MOV     R22, R0
   \   0000002A   2F08               MOV     R16, R24
   \   0000002C   7001               ANDI    R16, 0x01
   \   0000002E   E024               LDI     R18, 4
   \   00000030   9F02               MUL     R16, R18
   \   00000032   2960               OR      R22, R0
   \   00000034   E800               LDI     R16, 128
   \   00000036   9E30               MUL     R3, R16
   \   00000038   2960               OR      R22, R0
   \   0000003A   2971               OR      R23, R1
   \   0000003C   E008               LDI     R16, 8
   \   0000003E   9E20               MUL     R2, R16
   \   00000040   2960               OR      R22, R0
   \   00000042   2971               OR      R23, R1
   \   00000044   E002               LDI     R16, 2
   \   00000046   9F10               MUL     R17, R16
   \   00000048   2960               OR      R22, R0
   \   0000004A   2971               OR      R23, R1
   \   0000004C   758B               ANDI    R24, 0x5B
   \   0000004E   2F08               MOV     R16, R24
   \   00000050   ....               RCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_4:
   \   00000052   2B06               OR      R16, R22
   \   00000054   2F17               MOV     R17, R23
   \   00000056   9189               LD      R24, Y+
   \   00000058   9508               RET
     70          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   ....               RJMP    ??getEvenParityforTx
     71          
     72          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
     73          uint8_t CHammingCodes::findHammingError(uint16_t hamming)
   \                     ??findHammingError:
     74          {
   \   00000000   0108               MOVW    R1:R0, R17:R16
     75              uint8_t errCode = 0;
     76          
     77              errCode  = ((getEvenParityforRx(hamming & P3_POSI_12)) != ((hamming >> P3_BIT) & 0x0001)) << 3;
   \   00000002   E000               LDI     R16, 0
   \   00000004   701F               ANDI    R17, 0x0F
   \   00000006   ....               RCALL   ?Subroutine3
   \                     ??CrossCallReturnLabel_11:
   \   00000008   FA07               BST     R0, 7
   \   0000000A   E010               LDI     R17, 0
   \   0000000C   F910               BLD     R17, 0
   \   0000000E   1701               CP      R16, R17
   \   00000010   F011               BREQ    ??findHammingError_1
   \   00000012   E058               LDI     R21, 8
   \   00000014   C001               RJMP    ??findHammingError_2
   \                     ??findHammingError_1:
   \   00000016   E050               LDI     R21, 0
     78              errCode |= ((getEvenParityforRx(hamming & P2_POSI_12)) != ((hamming >> P2_BIT) & 0x0001)) << 2;
   \                     ??findHammingError_2:
   \   00000018   0180               MOVW    R17:R16, R1:R0
   \   0000001A   7700               ANDI    R16, 0x70
   \   0000001C   7018               ANDI    R17, 0x08
   \   0000001E   ....               RCALL   ?Subroutine3
   \                     ??CrossCallReturnLabel_10:
   \   00000020   FA03               BST     R0, 3
   \   00000022   ....               RCALL   ?Subroutine0
   \                     ??CrossCallReturnLabel_0:
   \   00000024   0F00               LSL     R16
   \   00000026   2B50               OR      R21, R16
     79              errCode |= ((getEvenParityforRx(hamming & P1_POSI_12)) != ((hamming >> P1_BIT) & 0x0001)) << 1;
   \   00000028   0180               MOVW    R17:R16, R1:R0
   \   0000002A   7604               ANDI    R16, 0x64
   \   0000002C   7016               ANDI    R17, 0x06
   \   0000002E   ....               RCALL   ?Subroutine3
   \                     ??CrossCallReturnLabel_9:
   \   00000030   FA01               BST     R0, 1
   \   00000032   ....               RCALL   ?Subroutine0
   \                     ??CrossCallReturnLabel_1:
   \   00000034   2B50               OR      R21, R16
     80              errCode |= ((getEvenParityforRx(hamming & P0_POSI_12)) != ((hamming >> P0_BIT) & 0x0001)) << 0;
   \   00000036   0180               MOVW    R17:R16, R1:R0
   \   00000038   7504               ANDI    R16, 0x54
   \   0000003A   7015               ANDI    R17, 0x05
   \   0000003C   ....               RCALL   ?Subroutine3
   \                     ??CrossCallReturnLabel_8:
   \   0000003E   2D10               MOV     R17, R0
   \   00000040   7011               ANDI    R17, 0x01
   \   00000042   ....               RCALL   ?Subroutine7
     81          
     82              return errCode;
   \                     ??CrossCallReturnLabel_22:
   \   00000044   2B05               OR      R16, R21
   \   00000046   9508               RET
     83          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   ....               RJMP    ??getEvenParityforRx

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   E010               LDI     R17, 0
   \   00000002   F910               BLD     R17, 0
   \   00000004   ....               RCALL   ?Subroutine7
   \                     ??CrossCallReturnLabel_23:
   \   00000006   0F00               LSL     R16
   \   00000008   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   00000000   1701               CP      R16, R17
   \   00000002   F009               BREQ    ??Subroutine7_0
   \   00000004   ....               RJMP    ?Subroutine9
   \                     ??Subroutine7_0:
   \   00000006   ....               RJMP    ?Subroutine10
     84          
     85          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
     86          uint16_t CHammingCodes::fixError(uint16_t hammingData, uint8_t errorCode)
   \                     ??fixError:
     87          {
   \   00000000   01B8               MOVW    R23:R22, R17:R16
     88              if (errorCode == NONE_ERROR)
   \   00000002   2322               TST     R18
   \   00000004   F051               BREQ    ??fixError_1
     89              {
     90                  return hammingData;
     91              }
     92              else
     93              {
     94                  m_uiErrorCode = errorCode;
   \   00000006   9320....           STS     ??m_uiErrorCode, R18
     95                  return hammingData ^ (1 << (errorCode - 1));
   \   0000000A   952A               DEC     R18
   \   0000000C   E001               LDI     R16, 1
   \   0000000E   E010               LDI     R17, 0
   \   00000010   2F42               MOV     R20, R18
   \   00000012   ........           CALL    ?S_SHL_L02
   \   00000016   2706               EOR     R16, R22
   \   00000018   2717               EOR     R17, R23
   \                     ??fixError_1:
   \   0000001A   9508               RET
     96              }
     97          
     98          }
     99          
    100          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    101          uint8_t CHammingCodes::deHamming(uint16_t hammingData)
   \                     ??deHamming:
    102          {
   \   00000000   2F20               MOV     R18, R16
    103              uint8_t data = 0;
    104          
    105              data = (hammingData >> BLOCK2_SHIFT) & BLOCK2;
    106              data |= (hammingData >> BLOCK1_SHIFT) & BLOCK1;
    107              data |= (hammingData >> BLOCK0_SHIFT) & BLOCK0;
    108          
    109              return data;
   \   00000002   E044               LDI     R20, 4
   \   00000004   ........           CALL    ?US_SHR_L02
   \   00000008   7F00               ANDI    R16, 0xF0
   \   0000000A   2F12               MOV     R17, R18
   \   0000000C   9516               LSR     R17
   \   0000000E   9516               LSR     R17
   \   00000010   9516               LSR     R17
   \   00000012   701E               ANDI    R17, 0x0E
   \   00000014   2B01               OR      R16, R17
   \   00000016   FB22               BST     R18, 2
   \   00000018   E010               LDI     R17, 0
   \   0000001A   F910               BLD     R17, 0
   \   0000001C   2B01               OR      R16, R17
   \   0000001E   9508               RET
    110          }
    111          
    112          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    113          uint8_t CHammingCodes::Recovery(uint16_t uiHammingData)
   \                     ??Recovery:
    114          {
   \   00000000   0118               MOVW    R3:R2, R17:R16
    115              return deHamming(fixError(uiHammingData, findHammingError(uiHammingData)));
   \   00000002   ....               RCALL   ??findHammingError
   \   00000004   2F20               MOV     R18, R16
   \   00000006   0181               MOVW    R17:R16, R3:R2
   \   00000008   ....               RCALL   ??fixError
   \   0000000A   ....               RJMP    ??deHamming
    116          }
    117          
    118          //-----------------------------------------------------------------------------------------------------
    119          // Вычисляет длину закодированных данных.

   \                                 In  segment CODE, align 2, keep-with-next
    120          uint16_t CHammingCodes::CalculateEncodedDataLength(uint16_t uiLength)
   \                     ??CalculateEncodedDataLength:
    121          {
    122              // Длина нечётная?
    123              if (uiLength & 1)
   \   00000000   FB00               BST     R16, 0
   \   00000002   F416               BRTC    ??CalculateEncodedDataLength_1
    124              {
    125                  // Выровняем длину.
    126                  uiLength += 1;
   \   00000004   5F0F               SUBI    R16, 255
   \   00000006   4F1F               SBCI    R17, 255
    127              }
    128          
    129              // uiLength * 1.5 (HammingCodes 8 + 4 на один байт приходится 12 закодированных бит).
    130              return (uiLength + (uiLength / 2));
   \                     ??CalculateEncodedDataLength_1:
   \   00000008   0198               MOVW    R19:R18, R17:R16
   \   0000000A   9536               LSR     R19
   \   0000000C   9527               ROR     R18
   \   0000000E   0F02               ADD     R16, R18
   \   00000010   1F13               ADC     R17, R19
   \   00000012   9508               RET
    131          }
    132          
    133          //-----------------------------------------------------------------------------------------------------
    134          // Кодирует буфер в код Хемминга.

   \                                 In  segment CODE, align 2, keep-with-next
    135          uint16_t CHammingCodes::BytesToHammingCodes(uint8_t* puiDestination, uint8_t* puiSource, uint16_t uiLength)
   \                     ??BytesToHammingCodes:
    136          {
   \   00000000   ........           CALL    ?PROLOGUE14_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R9_is_cg_reg
   \   00000004                      REQUIRE ?Register_R10_is_cg_reg
   \   00000004                      REQUIRE ?Register_R11_is_cg_reg
   \   00000004                      REQUIRE ?Register_R12_is_cg_reg
   \   00000004                      REQUIRE ?Register_R13_is_cg_reg
   \   00000004   9723               SBIW    R29:R28, 3
   \   00000006   0138               MOVW    R7:R6, R17:R16
   \   00000008   0149               MOVW    R9:R8, R19:R18
   \   0000000A   015A               MOVW    R11:R10, R21:R20
    137              uint16_t uiEncodedByteCounter = 0;
   \   0000000C   E080               LDI     R24, 0
   \   0000000E   E090               LDI     R25, 0
    138              uint16_t uiSourceIndex = 0;
   \   00000010   2444               CLR     R4
   \   00000012   2455               CLR     R5
    139              bool bTailIsPresent = false;
   \   00000014   8388               ST      Y, R24
    140          
    141              // Количество байт данных нечётное?
    142              if ((uiLength > 0) && (uiLength & 1))
   \   00000016   294B               OR      R20, R11
   \   00000018   F039               BREQ    ??BytesToHammingCodes_1
   \   0000001A   FAA0               BST     R10, 0
   \   0000001C   F42E               BRTC    ??BytesToHammingCodes_1
    143              {
    144                  uiLength -= 1;
   \   0000001E   EF0F               LDI     R16, 255
   \   00000020   0EA0               ADD     R10, R16
   \   00000022   1EB0               ADC     R11, R16
    145                  bTailIsPresent = true;
   \   00000024   E001               LDI     R16, 1
   \   00000026   8308               ST      Y, R16
    146              }
    147          
    148              // Закодируем все данные.
    149              for (uint16_t i = 0; i < uiLength; i += 2)
   \                     ??BytesToHammingCodes_1:
   \   00000028   8389               STD     Y+1, R24
   \   0000002A   838A               STD     Y+2, R24
   \   0000002C   C01A               RJMP    ??BytesToHammingCodes_2
    150              {
    151                  uint32_t uiData;
    152                  // Получим кодовое слово 12 бит.
    153                  uiData = static_cast<uint32_t>(enHamming(puiSource[uiSourceIndex]));
   \                     ??BytesToHammingCodes_3:
   \   0000002E   ....               RCALL   ?Subroutine5
   \                     ??CrossCallReturnLabel_15:
   \   00000030   ....               RCALL   ?Subroutine6
    154                  // Следующий байт источника.
    155                  uiSourceIndex++;
    156                  // Получим кодовое слово 12 бит.
    157                  uiData |= (static_cast<uint32_t>(enHamming(puiSource[uiSourceIndex])) << HAMMING_CODE_8_4_BIT_NUMBER);
   \                     ??CrossCallReturnLabel_21:
   \   00000032   0168               MOVW    R13:R12, R17:R16
   \   00000034   E001               LDI     R16, 1
   \   00000036   0E40               ADD     R4, R16
   \   00000038   E000               LDI     R16, 0
   \   0000003A   1E50               ADC     R5, R16
   \   0000003C   ....               RCALL   ?Subroutine5
   \                     ??CrossCallReturnLabel_16:
   \   0000003E   8100               LD      R16, Z
   \   00000040   ....               RCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_3:
   \   00000042   291D               OR      R17, R13
    158                  // Следующий байт источника.
    159                  uiSourceIndex++;
   \   00000044   E041               LDI     R20, 1
   \   00000046   0E44               ADD     R4, R20
   \   00000048   1E50               ADC     R5, R16
    160          
    161                  puiDestination[uiEncodedByteCounter] = static_cast<uint8_t>(uiData);
   \   0000004A   92CC               ST      X, R12
    162                  // Адрес следующего байта для сохранения.
    163                  // Увеличим количество закодированных байт.
    164                  uiEncodedByteCounter++;
    165                  uiData >>= 8;
    166                  puiDestination[uiEncodedByteCounter] = static_cast<uint8_t>(uiData);
   \   0000004C   ....               RCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_12:
   \   0000004E   8310               ST      Z, R17
    167                  // Адрес следующего байта для сохранения.
    168                  // Увеличим количество закодированных байт.
    169                  uiEncodedByteCounter++;
    170                  uiData >>= 8;
    171                  puiDestination[uiEncodedByteCounter] = static_cast<uint8_t>(uiData);
   \   00000050   ....               RCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_13:
   \   00000052   8320               ST      Z, R18
    172                  // Адрес следующего байта для сохранения.
    173                  // Увеличим количество закодированных байт.
    174                  uiEncodedByteCounter++;
   \   00000054   9601               ADIW    R25:R24, 1
    175              }
   \   00000056   8109               LDD     R16, Y+1
   \   00000058   811A               LDD     R17, Y+2
   \   0000005A   5F0E               SUBI    R16, 254
   \   0000005C   4F1F               SBCI    R17, 255
   \   0000005E   8309               STD     Y+1, R16
   \   00000060   831A               STD     Y+2, R17
   \                     ??BytesToHammingCodes_2:
   \   00000062   01D3               MOVW    R27:R26, R7:R6
   \   00000064   0FA8               ADD     R26, R24
   \   00000066   1FB9               ADC     R27, R25
   \   00000068   8109               LDD     R16, Y+1
   \   0000006A   811A               LDD     R17, Y+2
   \   0000006C   150A               CP      R16, R10
   \   0000006E   051B               CPC     R17, R11
   \   00000070   F2F0               BRCS    ??BytesToHammingCodes_3
    176          
    177              if (bTailIsPresent)
   \   00000072   8108               LD      R16, Y
   \   00000074   2300               TST     R16
   \   00000076   F089               BREQ    ??BytesToHammingCodes_4
    178              {
    179                  uint32_t uiData;
    180                  // Получим кодовое слово 12 бит.
    181                  uiData = static_cast<uint32_t>(enHamming(puiSource[uiSourceIndex]));
   \   00000078   0C84               ADD     R8, R4
   \   0000007A   1C95               ADC     R9, R5
   \   0000007C   01F4               MOVW    R31:R30, R9:R8
   \   0000007E   ....               RCALL   ?Subroutine6
    182                  // Получим кодовое слово 12 бит.
    183                  uiData |= (static_cast<uint32_t>(enHamming(0)) << HAMMING_CODE_8_4_BIT_NUMBER);
   \                     ??CrossCallReturnLabel_20:
   \   00000080   0148               MOVW    R9:R8, R17:R16
   \   00000082   E000               LDI     R16, 0
   \   00000084   ....               RCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_2:
   \   00000086   2A91               OR      R9, R17
    184          
    185                  puiDestination[uiEncodedByteCounter] = static_cast<uint8_t>(uiData);
   \   00000088   928C               ST      X, R8
    186                  // Адрес следующего байта для сохранения.
    187                  // Увеличим количество закодированных байт.
    188                  uiEncodedByteCounter++;
    189                  uiData >>= 8;
    190                  puiDestination[uiEncodedByteCounter] = static_cast<uint8_t>(uiData);
   \   0000008A   ....               RCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_14:
   \   0000008C   8290               ST      Z, R9
    191                  // Адрес следующего байта для сохранения.
    192                  // Увеличим количество закодированных байт.
    193                  uiEncodedByteCounter++;
    194                  uiData >>= 8;
    195                  puiDestination[uiEncodedByteCounter] = static_cast<uint8_t>(uiData);
   \   0000008E   9601               ADIW    R25:R24, 1
   \   00000090   0E68               ADD     R6, R24
   \   00000092   1E79               ADC     R7, R25
   \   00000094   01F3               MOVW    R31:R30, R7:R6
   \   00000096   8320               ST      Z, R18
    196                  // Адрес следующего байта для сохранения.
    197                  // Увеличим количество закодированных байт.
    198                  uiEncodedByteCounter++;
   \   00000098   9601               ADIW    R25:R24, 1
    199              }
    200          
    201              return uiEncodedByteCounter;
   \                     ??BytesToHammingCodes_4:
   \   0000009A   018C               MOVW    R17:R16, R25:R24
   \   0000009C   9623               ADIW    R29:R28, 3
   \   0000009E   E0EE               LDI     R30, 14
   \   000000A0   ........           JMP     ?EPILOGUE_B14_L09
    202          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   00000000   8100               LD      R16, Z
   \   00000002   ....               RJMP    ??enHamming

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   9601               ADIW    R25:R24, 1
   \   00000002   01F3               MOVW    R31:R30, R7:R6
   \   00000004   0FE8               ADD     R30, R24
   \   00000006   1FF9               ADC     R31, R25
   \   00000008   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   ....               RCALL   ??enHamming
   \   00000002   E020               LDI     R18, 0
   \   00000004   E030               LDI     R19, 0
   \   00000006   E04C               LDI     R20, 12
   \   00000008   ........           JMP     ?L_SHL_L03

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   00000000   01F4               MOVW    R31:R30, R9:R8
   \   00000002   0DE4               ADD     R30, R4
   \   00000004   1DF5               ADC     R31, R5
   \   00000006   9508               RET
    203          
    204          //-----------------------------------------------------------------------------------------------------
    205          // Декодирует буфер с кодом Хемминга.

   \                                 In  segment CODE, align 2, keep-with-next
    206          uint16_t CHammingCodes::HammingCodesToBytes(uint8_t* puiDestination, uint8_t* puiSource, uint16_t uiEncodedLength)
   \                     ??HammingCodesToBytes:
    207          {
   \   00000000   ........           CALL    ?PROLOGUE16_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R9_is_cg_reg
   \   00000004                      REQUIRE ?Register_R10_is_cg_reg
   \   00000004                      REQUIRE ?Register_R11_is_cg_reg
   \   00000004                      REQUIRE ?Register_R12_is_cg_reg
   \   00000004                      REQUIRE ?Register_R13_is_cg_reg
   \   00000004                      REQUIRE ?Register_R14_is_cg_reg
   \   00000004                      REQUIRE ?Register_R15_is_cg_reg
   \   00000004   0158               MOVW    R11:R10, R17:R16
   \   00000006   0149               MOVW    R9:R8, R19:R18
   \   00000008   017A               MOVW    R15:R14, R21:R20
    208              uint16_t uiDecodedByteCounter = 0;
   \   0000000A   2466               CLR     R6
   \   0000000C   2477               CLR     R7
    209              uint16_t uiSourceIndex = 0;
   \   0000000E   2444               CLR     R4
   \   00000010   2455               CLR     R5
    210          //    bool bTailIsPresent = false;
    211          
    212              // uiEncodedLength = (uiLength * 1.5) (HammingCodes 8 + 4 на один байт приходится 12 закодированных бит - всегда кратно трём).
    213              // Длина закодированных данных не кратно трём?
    214              if ((uiEncodedLength > 0) && (uiEncodedLength % 3) != 0)
   \   00000012   294F               OR      R20, R15
   \   00000014   F051               BREQ    ??HammingCodesToBytes_1
   \   00000016   E043               LDI     R20, 3
   \   00000018   E050               LDI     R21, 0
   \   0000001A   0187               MOVW    R17:R16, R15:R14
   \   0000001C   ........           CALL    ?US_DIVMOD_L02
   \   00000020   2941               OR      R20, R1
   \   00000022   F019               BREQ    ??HammingCodesToBytes_1
    215              {
    216                  // Ошибка - не достаточно данных для восстановления.
    217                  return 0;
   \   00000024   E000               LDI     R16, 0
   \   00000026   E010               LDI     R17, 0
   \   00000028   C032               RJMP    ??HammingCodesToBytes_2
    218              }
    219          
    220          //    // Количество байт данных нечётное?
    221          //    if ((uiEncodedLength % 3) == 2)
    222          //    {
    223          //        uiEncodedLength -= 2;
    224          //        bTailIsPresent = true;
    225          //    }
    226          
    227              // Декодируем все данные.
    228              for (uint16_t i = 0; i < uiEncodedLength; i += 3)
   \                     ??HammingCodesToBytes_1:
   \   0000002A   24CC               CLR     R12
   \   0000002C   24DD               CLR     R13
   \   0000002E   C02B               RJMP    ??HammingCodesToBytes_3
    229              {
    230                  uint32_t uiData;
    231          
    232                  uiData = (static_cast<uint32_t>(puiSource[uiSourceIndex]));
   \                     ??HammingCodesToBytes_4:
   \   00000030   ....               RCALL   ?Subroutine5
   \                     ??CrossCallReturnLabel_17:
   \   00000032   8180               LD      R24, Z
   \   00000034   E090               LDI     R25, 0
   \   00000036   E0A0               LDI     R26, 0
   \   00000038   E0B0               LDI     R27, 0
    233                  // Следующий байт источника.
    234                  uiSourceIndex++;
    235                  uiData |= (static_cast<uint32_t>(puiSource[uiSourceIndex]) << 8);
   \   0000003A   E001               LDI     R16, 1
   \   0000003C   0E40               ADD     R4, R16
   \   0000003E   1E59               ADC     R5, R25
   \   00000040   ....               RCALL   ?Subroutine5
   \                     ??CrossCallReturnLabel_18:
   \   00000042   8110               LD      R17, Z
   \   00000044   2F91               MOV     R25, R17
    236                  // Следующий байт источника.
    237                  uiSourceIndex++;
    238                  uiData |= (static_cast<uint32_t>(puiSource[uiSourceIndex]) << 16);
   \   00000046   0E40               ADD     R4, R16
   \   00000048   1E5A               ADC     R5, R26
   \   0000004A   ....               RCALL   ?Subroutine5
   \                     ??CrossCallReturnLabel_19:
   \   0000004C   81A0               LD      R26, Z
    239                  // Следующий байт источника.
    240                  uiSourceIndex++;
   \   0000004E   0E40               ADD     R4, R16
   \   00000050   1E5B               ADC     R5, R27
    241          
    242                  // Восстановим закодированный байт.
    243                  puiDestination[uiDecodedByteCounter] = Recovery((static_cast<uint16_t>(uiData) & 0x0FFF));
   \   00000052   2F08               MOV     R16, R24
   \   00000054   701F               ANDI    R17, 0x0F
   \   00000056   ....               RCALL   ??Recovery
   \   00000058   01F5               MOVW    R31:R30, R11:R10
   \   0000005A   0DE6               ADD     R30, R6
   \   0000005C   1DF7               ADC     R31, R7
   \   0000005E   8300               ST      Z, R16
    244                  // Увеличим количество декодированных байт.
    245                  uiDecodedByteCounter++;
    246                  // Восстановим закодированный байт.
    247                  puiDestination[uiDecodedByteCounter] = Recovery((static_cast<uint16_t>(uiData >> HAMMING_CODE_8_4_BIT_NUMBER) & 0x0FFF));
   \   00000060   E04C               LDI     R20, 12
   \   00000062   018C               MOVW    R17:R16, R25:R24
   \   00000064   019D               MOVW    R19:R18, R27:R26
   \   00000066   ........           CALL    ?UL_SHR_L03
   \   0000006A   ....               RCALL   ??Recovery
   \   0000006C   2F10               MOV     R17, R16
   \   0000006E   E001               LDI     R16, 1
   \   00000070   0E60               ADD     R6, R16
   \   00000072   1E7B               ADC     R7, R27
   \   00000074   01F5               MOVW    R31:R30, R11:R10
   \   00000076   0DE6               ADD     R30, R6
   \   00000078   1DF7               ADC     R31, R7
   \   0000007A   8310               ST      Z, R17
    248                  // Увеличим количество декодированных байт.
    249                  uiDecodedByteCounter++;
   \   0000007C   0E60               ADD     R6, R16
   \   0000007E   1E7B               ADC     R7, R27
    250              }
   \   00000080   E003               LDI     R16, 3
   \   00000082   0EC0               ADD     R12, R16
   \   00000084   1EDB               ADC     R13, R27
   \                     ??HammingCodesToBytes_3:
   \   00000086   14CE               CP      R12, R14
   \   00000088   04DF               CPC     R13, R15
   \   0000008A   F290               BRCS    ??HammingCodesToBytes_4
    251          
    252          //    if (bTailIsPresent)
    253          //    {
    254          //        uint16_t uiData;
    255          //
    256          //        uiData = (static_cast<uint16_t>(puiSource[uiSourceIndex]));
    257          //        // Следующий байт источника.
    258          //        uiSourceIndex++;
    259          //        uiData |= (static_cast<uint16_t>(puiSource[uiSourceIndex]) << 8);
    260          //
    261          //        // Восстановим закодированный байт.
    262          //        puiDestination[uiDecodedByteCounter] = Recovery(uiData & 0x0FFF);
    263          //        // Увеличим количество декодированных байт.
    264          //        uiDecodedByteCounter++;
    265          //    }
    266          
    267              return uiDecodedByteCounter;
   \   0000008C   0183               MOVW    R17:R16, R7:R6
   \                     ??HammingCodesToBytes_2:
   \   0000008E   E1E0               LDI     R30, 16
   \   00000090   ........           JMP     ?EPILOGUE_B16_L09
    268          }
    269          
    270          //-----------------------------------------------------------------------------------------------------

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
     17      2   CHammingCodes::BytesToHammingCodes(uint8_t *, uint8_t *, uint16_t)
       17      2   -> CHammingCodes::enHamming(uint8_t)
       17      4   -> CHammingCodes::enHamming(uint8_t)
       17      2 ?L_SHL_L03
      0      2   CHammingCodes::CalculateEncodedDataLength(uint16_t)
     16      2   CHammingCodes::HammingCodesToBytes(uint8_t *, uint8_t *, uint16_t)
       16      2   -> CHammingCodes::Recovery(uint16_t)
       16      2 ?UL_SHR_L03
       16      2 ?US_DIVMOD_L02
      0      2   CHammingCodes::Recovery(uint16_t)
        0      2   -> CHammingCodes::deHamming(uint16_t)
        0      2   -> CHammingCodes::findHammingError(uint16_t)
        0      2   -> CHammingCodes::fixError(uint16_t, uint8_t)
      0      2   CHammingCodes::deHamming(uint16_t)
        0      2 ?US_SHR_L02
      1      2   CHammingCodes::enHamming(uint8_t)
        1      2   -> CHammingCodes::getEvenParityforTx(uint8_t)
      0      2   CHammingCodes::findHammingError(uint16_t)
        0      2   -> CHammingCodes::getEvenParityforRx(uint16_t)
      0      2   CHammingCodes::fixError(uint16_t, uint8_t)
        0      2 ?S_SHL_L02
      0      2   CHammingCodes::getEvenParityforRx(uint16_t)
        0      2 ?US_SHR_L02
      0      2   CHammingCodes::getEvenParityforTx(uint8_t)
        0      2 ?SS_SHR_L02


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      10  ?Subroutine0
      12  ?Subroutine1
       4  ?Subroutine10
       2  ?Subroutine2
       2  ?Subroutine3
      10  ?Subroutine4
       8  ?Subroutine5
       4  ?Subroutine6
       8  ?Subroutine7
       4  ?Subroutine9
     164  CHammingCodes::BytesToHammingCodes(uint8_t *, uint8_t *, uint16_t)
      20  CHammingCodes::CalculateEncodedDataLength(uint16_t)
     148  CHammingCodes::HammingCodesToBytes(uint8_t *, uint8_t *, uint16_t)
      12  CHammingCodes::Recovery(uint16_t)
      32  CHammingCodes::deHamming(uint16_t)
      90  CHammingCodes::enHamming(uint8_t)
      72  CHammingCodes::findHammingError(uint16_t)
      28  CHammingCodes::fixError(uint16_t, uint8_t)
      36  CHammingCodes::getEvenParityforRx(uint16_t)
      38  CHammingCodes::getEvenParityforTx(uint8_t)
       1  CHammingCodes::m_uiErrorCode
       7  -- Other

 
 704 bytes in segment CODE
   7 bytes in segment INITTAB
   1 byte  in segment NEAR_Z
 
 704 bytes of CODE memory (+ 7 bytes shared)
   1 byte  of DATA memory

Errors: none
Warnings: none

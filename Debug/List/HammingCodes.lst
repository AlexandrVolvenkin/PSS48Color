###############################################################################
#
# IAR C/C++ Compiler V7.10.6.1378 for Atmel AVR           12/Oct/2024  00:09:09
# Copyright 1996-2018 IAR Systems AB.
#
#    Source file  =  
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\src\HammingCodes.cpp
#    Command line =  
#        -f C:\Users\Admin\AppData\Local\Temp\EWE501.tmp
#        (--string_literals_in_flash
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\src\HammingCodes.cpp
#        --cpu=m128a -ms -o
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\Obj -lC
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\List -lB
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\List -y
#        --initializers_in_flash --root_variables --no_cse --no_inline
#        --no_code_motion --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e -I
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Modbus\ -I
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\include\
#        --eeprom_size 4096 --dlib --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On
#        --eec++)
#    Locale       =  Russian_RUS.1251
#    List file    =  
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\List\HammingCodes.lst
#    Object file  =  
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\Obj\HammingCodes.r90
#
###############################################################################

D:\Projects\CurrentProjects\CautoProjects\PSS48Color\src\HammingCodes.cpp
      1          
      2          //-----------------------------------------------------------------------------------------------------
      3          //  Based on    : https://github.com/Minho-Cha/8bit-Hamming-Code
      4          //  Source      : FileName.cpp
      5          //  Created     : 01.06.2022
      6          //  Author      : Alexandr Volvenkin
      7          //  email       : aav-36@mail.ru
      8          //  GitHub      : https://github.com/AlexandrVolvenkin
      9          //-----------------------------------------------------------------------------------------------------
     10          #include "HammingCodes.h"
     11          #include "Crc.h"
     12          
     13          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment NEAR_Z, align 1, keep-with-next, root
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     14          uint8_t CHammingCodes::m_uiErrorCode;
   \                     ??m_uiErrorCode:
   \   00000000                      DS8 1
     15          
     16          ////-----------------------------------------------------------------------------------------------------
     17          //CHammingCodes::CHammingCodes()
     18          //{
     19          //    //ctor
     20          //}
     21          //
     22          ////-----------------------------------------------------------------------------------------------------
     23          //CHammingCodes::~CHammingCodes()
     24          //{
     25          //    //dtor
     26          //}
     27          
     28          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
     29          uint8_t CHammingCodes::getEvenParityforTx(uint8_t data) //?? ???
   \                     ??getEvenParityforTx:
     30          {
   \   00000000   2F20               MOV     R18, R16
     31              uint8_t parity = 0;
   \   00000002   E030               LDI     R19, 0
     32              for (int i = 0; i < 8; i++)
   \   00000004   E0E0               LDI     R30, 0
   \   00000006   E0F0               LDI     R31, 0
   \                     ??getEvenParityforTx_1:
   \   00000008   30E8               CPI     R30, 8
   \   0000000A   E000               LDI     R16, 0
   \   0000000C   07F0               CPC     R31, R16
   \   0000000E   F44C               BRGE    ??getEvenParityforTx_2
     33              {
     34                  parity ^= (data >> i) & 0x01;
   \   00000010   2F02               MOV     R16, R18
   \   00000012   E010               LDI     R17, 0
   \   00000014   2F4E               MOV     R20, R30
   \   00000016   ........           CALL    ?SS_SHR_L02
   \   0000001A   7001               ANDI    R16, 0x01
   \   0000001C   2730               EOR     R19, R16
     35              }
   \   0000001E   9631               ADIW    R31:R30, 1
   \   00000020   CFF3               RJMP    ??getEvenParityforTx_1
     36          
     37              return !parity;
   \                     ??getEvenParityforTx_2:
   \   00000022   2333               TST     R19
   \   00000024   F411               BRNE    ??getEvenParityforTx_3
   \   00000026   E001               LDI     R16, 1
   \   00000028   9508               RET
   \                     ??getEvenParityforTx_3:
   \   0000002A   E000               LDI     R16, 0
   \   0000002C   9508               RET
     38          }
     39          
     40          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
     41          uint8_t CHammingCodes::getEvenParityforRx(uint16_t data) //?? ???
   \                     ??getEvenParityforRx:
     42          {
   \   00000000   0198               MOVW    R19:R18, R17:R16
     43              uint8_t parity = 0;
   \   00000002   E050               LDI     R21, 0
     44              for (int i = 0; i < 12; i++)
   \   00000004   E0E0               LDI     R30, 0
   \   00000006   E0F0               LDI     R31, 0
   \                     ??getEvenParityforRx_1:
   \   00000008   30EC               CPI     R30, 12
   \   0000000A   E000               LDI     R16, 0
   \   0000000C   07F0               CPC     R31, R16
   \   0000000E   F444               BRGE    ??getEvenParityforRx_2
     45              {
     46                  parity ^= (data >> i) & 0x01;
   \   00000010   2F4E               MOV     R20, R30
   \   00000012   0189               MOVW    R17:R16, R19:R18
   \   00000014   ........           CALL    ?US_SHR_L02
   \   00000018   7001               ANDI    R16, 0x01
   \   0000001A   2750               EOR     R21, R16
     47              }
   \   0000001C   9631               ADIW    R31:R30, 1
   \   0000001E   CFF4               RJMP    ??getEvenParityforRx_1
     48          
     49              return !parity;
   \                     ??getEvenParityforRx_2:
   \   00000020   2355               TST     R21
   \   00000022   F411               BRNE    ??getEvenParityforRx_3
   \   00000024   E001               LDI     R16, 1
   \   00000026   9508               RET
   \                     ??getEvenParityforRx_3:
   \   00000028   E000               LDI     R16, 0
   \   0000002A   9508               RET
     50          }
     51          
     52          //-----------------------------------------------------------------------------------------------------
     53          // Get Hamming code

   \                                 In  segment CODE, align 2, keep-with-next
     54          uint16_t CHammingCodes::enHamming(uint8_t data)
   \                     ??enHamming:
     55          {
   \   00000000   2F50               MOV     R21, R16
     56              uint16_t hamming = 0;
   \   00000002   E060               LDI     R22, 0
   \   00000004   E070               LDI     R23, 0
     57          
     58              // Set Data
     59              hamming = (data & BLOCK2) << BLOCK2_SHIFT;  //0b1111 0000 0000
   \   00000006   E100               LDI     R16, 16
   \   00000008   9F50               MUL     R21, R16
   \   0000000A   E000               LDI     R16, 0
   \   0000000C   2200               AND     R0, R16
   \   0000000E   E00F               LDI     R16, 15
   \   00000010   2210               AND     R1, R16
   \   00000012   01B0               MOVW    R23:R22, R1:R0
     60              hamming |= (data & BLOCK1) << BLOCK1_SHIFT;  //0b0000 0111 0000
   \   00000014   E008               LDI     R16, 8
   \   00000016   9F50               MUL     R21, R16
   \   00000018   E700               LDI     R16, 112
   \   0000001A   2200               AND     R0, R16
   \   0000001C   E000               LDI     R16, 0
   \   0000001E   2210               AND     R1, R16
   \   00000020   2960               OR      R22, R0
   \   00000022   2971               OR      R23, R1
     61              hamming |= (data & BLOCK0) << BLOCK0_SHIFT;  //0b0000 0000 0100
   \   00000024   2F05               MOV     R16, R21
   \   00000026   7001               ANDI    R16, 0x01
   \   00000028   E014               LDI     R17, 4
   \   0000002A   9F01               MUL     R16, R17
   \   0000002C   2960               OR      R22, R0
   \   0000002E   2971               OR      R23, R1
     62          
     63              // Set Parity
     64              hamming |= getEvenParityforTx(data & P3_POSI_8) << P3_BIT; // 0b1111 0000
   \   00000030   2F05               MOV     R16, R21
   \   00000032   7F00               ANDI    R16, 0xF0
   \   00000034   ....               RCALL   ??getEvenParityforTx
   \   00000036   E810               LDI     R17, 128
   \   00000038   9F01               MUL     R16, R17
   \   0000003A   2960               OR      R22, R0
   \   0000003C   2971               OR      R23, R1
     65              hamming |= getEvenParityforTx(data & P2_POSI_8) << P2_BIT; // 0b1000 1110
   \   0000003E   2F05               MOV     R16, R21
   \   00000040   780E               ANDI    R16, 0x8E
   \   00000042   ....               RCALL   ??getEvenParityforTx
   \   00000044   E018               LDI     R17, 8
   \   00000046   9F01               MUL     R16, R17
   \   00000048   2960               OR      R22, R0
   \   0000004A   2971               OR      R23, R1
     66              hamming |= getEvenParityforTx(data & P1_POSI_8) << P1_BIT; // 0b0110 1101
   \   0000004C   2F05               MOV     R16, R21
   \   0000004E   760D               ANDI    R16, 0x6D
   \   00000050   ....               RCALL   ??getEvenParityforTx
   \   00000052   E012               LDI     R17, 2
   \   00000054   9F01               MUL     R16, R17
   \   00000056   2960               OR      R22, R0
   \   00000058   2971               OR      R23, R1
     67              hamming |= getEvenParityforTx(data & P0_POSI_8) << P0_BIT; // 0b0101 1011
   \   0000005A   2F05               MOV     R16, R21
   \   0000005C   750B               ANDI    R16, 0x5B
   \   0000005E   ....               RCALL   ??getEvenParityforTx
   \   00000060   E010               LDI     R17, 0
   \   00000062   2B60               OR      R22, R16
   \   00000064   2B71               OR      R23, R17
     68          
     69              return hamming;
   \   00000066   018B               MOVW    R17:R16, R23:R22
   \   00000068   9508               RET
     70          }
     71          
     72          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
     73          uint8_t CHammingCodes::findHammingError(uint16_t hamming)
   \                     ??findHammingError:
     74          {
   \   00000000   0108               MOVW    R1:R0, R17:R16
     75              uint8_t errCode = 0;
   \   00000002   E060               LDI     R22, 0
     76          
     77              errCode  = ((getEvenParityforRx(hamming & P3_POSI_12)) != ((hamming >> P3_BIT) & 0x0001)) << 3;
   \   00000004   0180               MOVW    R17:R16, R1:R0
   \   00000006   7000               ANDI    R16, 0x00
   \   00000008   701F               ANDI    R17, 0x0F
   \   0000000A   ....               RCALL   ??getEvenParityforRx
   \   0000000C   2D10               MOV     R17, R0
   \   0000000E   FB17               BST     R17, 7
   \   00000010   E010               LDI     R17, 0
   \   00000012   F910               BLD     R17, 0
   \   00000014   1701               CP      R16, R17
   \   00000016   F011               BREQ    ??findHammingError_1
   \   00000018   E061               LDI     R22, 1
   \   0000001A   C001               RJMP    ??findHammingError_2
   \                     ??findHammingError_1:
   \   0000001C   E060               LDI     R22, 0
   \                     ??findHammingError_2:
   \   0000001E   0F66               LSL     R22
   \   00000020   0F66               LSL     R22
   \   00000022   0F66               LSL     R22
     78              errCode |= ((getEvenParityforRx(hamming & P2_POSI_12)) != ((hamming >> P2_BIT) & 0x0001)) << 2;
   \   00000024   0180               MOVW    R17:R16, R1:R0
   \   00000026   7700               ANDI    R16, 0x70
   \   00000028   7018               ANDI    R17, 0x08
   \   0000002A   ....               RCALL   ??getEvenParityforRx
   \   0000002C   2D10               MOV     R17, R0
   \   0000002E   FB13               BST     R17, 3
   \   00000030   E010               LDI     R17, 0
   \   00000032   F910               BLD     R17, 0
   \   00000034   1701               CP      R16, R17
   \   00000036   F011               BREQ    ??findHammingError_3
   \   00000038   E001               LDI     R16, 1
   \   0000003A   C001               RJMP    ??findHammingError_4
   \                     ??findHammingError_3:
   \   0000003C   E000               LDI     R16, 0
   \                     ??findHammingError_4:
   \   0000003E   0F00               LSL     R16
   \   00000040   0F00               LSL     R16
   \   00000042   2B60               OR      R22, R16
     79              errCode |= ((getEvenParityforRx(hamming & P1_POSI_12)) != ((hamming >> P1_BIT) & 0x0001)) << 1;
   \   00000044   0180               MOVW    R17:R16, R1:R0
   \   00000046   7604               ANDI    R16, 0x64
   \   00000048   7016               ANDI    R17, 0x06
   \   0000004A   ....               RCALL   ??getEvenParityforRx
   \   0000004C   2D10               MOV     R17, R0
   \   0000004E   FB11               BST     R17, 1
   \   00000050   E010               LDI     R17, 0
   \   00000052   F910               BLD     R17, 0
   \   00000054   1701               CP      R16, R17
   \   00000056   F011               BREQ    ??findHammingError_5
   \   00000058   E001               LDI     R16, 1
   \   0000005A   C001               RJMP    ??findHammingError_6
   \                     ??findHammingError_5:
   \   0000005C   E000               LDI     R16, 0
   \                     ??findHammingError_6:
   \   0000005E   0F00               LSL     R16
   \   00000060   2B60               OR      R22, R16
     80              errCode |= ((getEvenParityforRx(hamming & P0_POSI_12)) != ((hamming >> P0_BIT) & 0x0001)) << 0;
   \   00000062   0180               MOVW    R17:R16, R1:R0
   \   00000064   7504               ANDI    R16, 0x54
   \   00000066   7015               ANDI    R17, 0x05
   \   00000068   ....               RCALL   ??getEvenParityforRx
   \   0000006A   2D10               MOV     R17, R0
   \   0000006C   7011               ANDI    R17, 0x01
   \   0000006E   1701               CP      R16, R17
   \   00000070   F011               BREQ    ??findHammingError_7
   \   00000072   E001               LDI     R16, 1
   \   00000074   C001               RJMP    ??findHammingError_8
   \                     ??findHammingError_7:
   \   00000076   E000               LDI     R16, 0
   \                     ??findHammingError_8:
   \   00000078   2B60               OR      R22, R16
     81          
     82              return errCode;
   \   0000007A   2F06               MOV     R16, R22
   \   0000007C   9508               RET
     83          }
     84          
     85          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
     86          uint16_t CHammingCodes::fixError(uint16_t hammingData, uint8_t errorCode)
   \                     ??fixError:
     87          {
   \   00000000   01B8               MOVW    R23:R22, R17:R16
     88              if (errorCode == NONE_ERROR)
   \   00000002   2322               TST     R18
   \   00000004   F411               BRNE    ??fixError_1
     89              {
     90                  return hammingData;
   \   00000006   018B               MOVW    R17:R16, R23:R22
   \   00000008   9508               RET
     91              }
     92              else
     93              {
     94                  m_uiErrorCode = errorCode;
   \                     ??fixError_1:
   \   0000000A   9320....           STS     ??m_uiErrorCode, R18
     95                  return hammingData ^ (1 << (errorCode - 1));
   \   0000000E   952A               DEC     R18
   \   00000010   E001               LDI     R16, 1
   \   00000012   E010               LDI     R17, 0
   \   00000014   2F42               MOV     R20, R18
   \   00000016   ........           CALL    ?S_SHL_L02
   \   0000001A   2760               EOR     R22, R16
   \   0000001C   2771               EOR     R23, R17
   \   0000001E   018B               MOVW    R17:R16, R23:R22
   \   00000020   9508               RET
     96              }
     97          
     98          }
     99          
    100          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    101          uint8_t CHammingCodes::deHamming(uint16_t hammingData)
   \                     ??deHamming:
    102          {
   \   00000000   01B8               MOVW    R23:R22, R17:R16
    103              uint8_t data = 0;
   \   00000002   E020               LDI     R18, 0
    104          
    105              data = (hammingData >> BLOCK2_SHIFT) & BLOCK2;
   \   00000004   E044               LDI     R20, 4
   \   00000006   018B               MOVW    R17:R16, R23:R22
   \   00000008   ........           CALL    ?US_SHR_L02
   \   0000000C   7F00               ANDI    R16, 0xF0
   \   0000000E   2F20               MOV     R18, R16
    106              data |= (hammingData >> BLOCK1_SHIFT) & BLOCK1;
   \   00000010   2F06               MOV     R16, R22
   \   00000012   9506               LSR     R16
   \   00000014   9506               LSR     R16
   \   00000016   9506               LSR     R16
   \   00000018   700E               ANDI    R16, 0x0E
   \   0000001A   2B20               OR      R18, R16
    107              data |= (hammingData >> BLOCK0_SHIFT) & BLOCK0;
   \   0000001C   2F06               MOV     R16, R22
   \   0000001E   FB02               BST     R16, 2
   \   00000020   E000               LDI     R16, 0
   \   00000022   F900               BLD     R16, 0
   \   00000024   2B20               OR      R18, R16
    108          
    109              return data;
   \   00000026   2F02               MOV     R16, R18
   \   00000028   9508               RET
    110          }
    111          
    112          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    113          uint8_t CHammingCodes::Recovery(uint16_t uiHammingData)
   \                     ??Recovery:
    114          {
   \   00000000   0118               MOVW    R3:R2, R17:R16
    115              return deHamming(fixError(uiHammingData, findHammingError(uiHammingData)));
   \   00000002   0181               MOVW    R17:R16, R3:R2
   \   00000004   ....               RCALL   ??findHammingError
   \   00000006   2F20               MOV     R18, R16
   \   00000008   0181               MOVW    R17:R16, R3:R2
   \   0000000A   ....               RCALL   ??fixError
   \   0000000C   ....               RCALL   ??deHamming
   \   0000000E   9508               RET
    116          }
    117          
    118          //-----------------------------------------------------------------------------------------------------
    119          // Вычисляет длину закодированных данных.

   \                                 In  segment CODE, align 2, keep-with-next
    120          uint16_t CHammingCodes::CalculateEncodedDataLength(uint16_t uiLength)
   \                     ??CalculateEncodedDataLength:
    121          {
    122              // Длина нечётная?
    123              if (uiLength & 1)
   \   00000000   FB00               BST     R16, 0
   \   00000002   F416               BRTC    ??CalculateEncodedDataLength_1
    124              {
    125                  // Выровняем длину.
    126                  uiLength += 1;
   \   00000004   5F0F               SUBI    R16, 255
   \   00000006   4F1F               SBCI    R17, 255
    127              }
    128          
    129              // uiLength * 1.5 (HammingCodes 8 + 4 на один байт приходится 12 закодированных бит).
    130              return (uiLength + (uiLength / 2));
   \                     ??CalculateEncodedDataLength_1:
   \   00000008   0198               MOVW    R19:R18, R17:R16
   \   0000000A   9536               LSR     R19
   \   0000000C   9527               ROR     R18
   \   0000000E   0F02               ADD     R16, R18
   \   00000010   1F13               ADC     R17, R19
   \   00000012   9508               RET
    131          }
    132          
    133          //-----------------------------------------------------------------------------------------------------
    134          // Кодирует буфер в код Хемминга.

   \                                 In  segment CODE, align 2, keep-with-next
    135          uint16_t CHammingCodes::BytesToHammingCodes(uint8_t* puiDestination, uint8_t* puiSource, uint16_t uiLength)
   \                     ??BytesToHammingCodes:
    136          {
   \   00000000   ........           CALL    ?PROLOGUE15_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R9_is_cg_reg
   \   00000004                      REQUIRE ?Register_R10_is_cg_reg
   \   00000004                      REQUIRE ?Register_R11_is_cg_reg
   \   00000004                      REQUIRE ?Register_R12_is_cg_reg
   \   00000004                      REQUIRE ?Register_R13_is_cg_reg
   \   00000004                      REQUIRE ?Register_R14_is_cg_reg
   \   00000004   0138               MOVW    R7:R6, R17:R16
   \   00000006   0159               MOVW    R11:R10, R19:R18
   \   00000008   016A               MOVW    R13:R12, R21:R20
    137              uint16_t uiEncodedByteCounter = 0;
   \   0000000A   2422               CLR     R2
   \   0000000C   2433               CLR     R3
    138              uint16_t uiSourceIndex = 0;
   \   0000000E   2444               CLR     R4
   \   00000010   2455               CLR     R5
    139              bool bTailIsPresent = false;
   \   00000012   24EE               CLR     R14
    140          
    141              // Количество байт данных нечётное?
    142              if ((uiLength > 0) && (uiLength & 1))
   \   00000014   2D0C               MOV     R16, R12
   \   00000016   290D               OR      R16, R13
   \   00000018   F041               BREQ    ??BytesToHammingCodes_1
   \   0000001A   FAC0               BST     R12, 0
   \   0000001C   F436               BRTC    ??BytesToHammingCodes_1
    143              {
    144                  uiLength -= 1;
   \   0000001E   EF0F               LDI     R16, 255
   \   00000020   0EC0               ADD     R12, R16
   \   00000022   EF0F               LDI     R16, 255
   \   00000024   1ED0               ADC     R13, R16
    145                  bTailIsPresent = true;
   \   00000026   24EE               CLR     R14
   \   00000028   94E3               INC     R14
    146              }
    147          
    148              // Закодируем все данные.
    149              for (uint16_t i = 0; i < uiLength; i += 2)
   \                     ??BytesToHammingCodes_1:
   \   0000002A   2488               CLR     R8
   \   0000002C   2499               CLR     R9
   \                     ??BytesToHammingCodes_2:
   \   0000002E   148C               CP      R8, R12
   \   00000030   049D               CPC     R9, R13
   \   00000032   F008               BRCS    $+2+2
   \   00000034   C04B               RJMP    ??BytesToHammingCodes_3
    150              {
    151                  uint32_t uiData;
    152                  // Получим кодовое слово 12 бит.
    153                  uiData = static_cast<uint32_t>(enHamming(puiSource[uiSourceIndex]));
   \   00000036   01F5               MOVW    R31:R30, R11:R10
   \   00000038   0DE4               ADD     R30, R4
   \   0000003A   1DF5               ADC     R31, R5
   \   0000003C   8100               LD      R16, Z
   \   0000003E   ....               RCALL   ??enHamming
   \   00000040   E020               LDI     R18, 0
   \   00000042   E030               LDI     R19, 0
   \   00000044   01C8               MOVW    R25:R24, R17:R16
   \   00000046   01D9               MOVW    R27:R26, R19:R18
    154                  // Следующий байт источника.
    155                  uiSourceIndex++;
   \   00000048   E001               LDI     R16, 1
   \   0000004A   0E40               ADD     R4, R16
   \   0000004C   E000               LDI     R16, 0
   \   0000004E   1E50               ADC     R5, R16
    156                  // Получим кодовое слово 12 бит.
    157                  uiData |= (static_cast<uint32_t>(enHamming(puiSource[uiSourceIndex])) << HAMMING_CODE_8_4_BIT_NUMBER);
   \   00000050   01F5               MOVW    R31:R30, R11:R10
   \   00000052   0DE4               ADD     R30, R4
   \   00000054   1DF5               ADC     R31, R5
   \   00000056   8100               LD      R16, Z
   \   00000058   ....               RCALL   ??enHamming
   \   0000005A   01A8               MOVW    R21:R20, R17:R16
   \   0000005C   E060               LDI     R22, 0
   \   0000005E   E070               LDI     R23, 0
   \   00000060   E0EC               LDI     R30, 12
   \   00000062   018A               MOVW    R17:R16, R21:R20
   \   00000064   019B               MOVW    R19:R18, R23:R22
   \   00000066   2F4E               MOV     R20, R30
   \   00000068   ........           CALL    ?L_SHL_L03
   \   0000006C   2B80               OR      R24, R16
   \   0000006E   2B91               OR      R25, R17
   \   00000070   2BA2               OR      R26, R18
   \   00000072   2BB3               OR      R27, R19
    158                  // Следующий байт источника.
    159                  uiSourceIndex++;
   \   00000074   E001               LDI     R16, 1
   \   00000076   0E40               ADD     R4, R16
   \   00000078   E000               LDI     R16, 0
   \   0000007A   1E50               ADC     R5, R16
    160          
    161                  puiDestination[uiEncodedByteCounter] = static_cast<uint8_t>(uiData);
   \   0000007C   018C               MOVW    R17:R16, R25:R24
   \   0000007E   01F3               MOVW    R31:R30, R7:R6
   \   00000080   0DE2               ADD     R30, R2
   \   00000082   1DF3               ADC     R31, R3
   \   00000084   8300               ST      Z, R16
    162                  // Адрес следующего байта для сохранения.
    163                  // Увеличим количество закодированных байт.
    164                  uiEncodedByteCounter++;
   \   00000086   E001               LDI     R16, 1
   \   00000088   0E20               ADD     R2, R16
   \   0000008A   E000               LDI     R16, 0
   \   0000008C   1E30               ADC     R3, R16
    165                  uiData >>= 8;
   \   0000008E   2F89               MOV     R24, R25
   \   00000090   2F9A               MOV     R25, R26
   \   00000092   2FAB               MOV     R26, R27
   \   00000094   E0B0               LDI     R27, 0
    166                  puiDestination[uiEncodedByteCounter] = static_cast<uint8_t>(uiData);
   \   00000096   018C               MOVW    R17:R16, R25:R24
   \   00000098   01F3               MOVW    R31:R30, R7:R6
   \   0000009A   0DE2               ADD     R30, R2
   \   0000009C   1DF3               ADC     R31, R3
   \   0000009E   8300               ST      Z, R16
    167                  // Адрес следующего байта для сохранения.
    168                  // Увеличим количество закодированных байт.
    169                  uiEncodedByteCounter++;
   \   000000A0   E001               LDI     R16, 1
   \   000000A2   0E20               ADD     R2, R16
   \   000000A4   E000               LDI     R16, 0
   \   000000A6   1E30               ADC     R3, R16
    170                  uiData >>= 8;
   \   000000A8   2F89               MOV     R24, R25
   \   000000AA   2F9A               MOV     R25, R26
   \   000000AC   2FAB               MOV     R26, R27
   \   000000AE   E0B0               LDI     R27, 0
    171                  puiDestination[uiEncodedByteCounter] = static_cast<uint8_t>(uiData);
   \   000000B0   018C               MOVW    R17:R16, R25:R24
   \   000000B2   01F3               MOVW    R31:R30, R7:R6
   \   000000B4   0DE2               ADD     R30, R2
   \   000000B6   1DF3               ADC     R31, R3
   \   000000B8   8300               ST      Z, R16
    172                  // Адрес следующего байта для сохранения.
    173                  // Увеличим количество закодированных байт.
    174                  uiEncodedByteCounter++;
   \   000000BA   E001               LDI     R16, 1
   \   000000BC   0E20               ADD     R2, R16
   \   000000BE   E000               LDI     R16, 0
   \   000000C0   1E30               ADC     R3, R16
    175              }
   \   000000C2   E002               LDI     R16, 2
   \   000000C4   0E80               ADD     R8, R16
   \   000000C6   E000               LDI     R16, 0
   \   000000C8   1E90               ADC     R9, R16
   \   000000CA   CFB1               RJMP    ??BytesToHammingCodes_2
    176          
    177              if (bTailIsPresent)
   \                     ??BytesToHammingCodes_3:
   \   000000CC   20EE               TST     R14
   \   000000CE   F1D9               BREQ    ??BytesToHammingCodes_4
    178              {
    179                  uint32_t uiData;
    180                  // Получим кодовое слово 12 бит.
    181                  uiData = static_cast<uint32_t>(enHamming(puiSource[uiSourceIndex]));
   \   000000D0   01F5               MOVW    R31:R30, R11:R10
   \   000000D2   0DE4               ADD     R30, R4
   \   000000D4   1DF5               ADC     R31, R5
   \   000000D6   8100               LD      R16, Z
   \   000000D8   ....               RCALL   ??enHamming
   \   000000DA   E020               LDI     R18, 0
   \   000000DC   E030               LDI     R19, 0
   \   000000DE   01C8               MOVW    R25:R24, R17:R16
   \   000000E0   01D9               MOVW    R27:R26, R19:R18
    182                  // Получим кодовое слово 12 бит.
    183                  uiData |= (static_cast<uint32_t>(enHamming(0)) << HAMMING_CODE_8_4_BIT_NUMBER);
   \   000000E2   E000               LDI     R16, 0
   \   000000E4   ....               RCALL   ??enHamming
   \   000000E6   01A8               MOVW    R21:R20, R17:R16
   \   000000E8   E060               LDI     R22, 0
   \   000000EA   E070               LDI     R23, 0
   \   000000EC   E0EC               LDI     R30, 12
   \   000000EE   018A               MOVW    R17:R16, R21:R20
   \   000000F0   019B               MOVW    R19:R18, R23:R22
   \   000000F2   2F4E               MOV     R20, R30
   \   000000F4   ........           CALL    ?L_SHL_L03
   \   000000F8   2B80               OR      R24, R16
   \   000000FA   2B91               OR      R25, R17
   \   000000FC   2BA2               OR      R26, R18
   \   000000FE   2BB3               OR      R27, R19
    184          
    185                  puiDestination[uiEncodedByteCounter] = static_cast<uint8_t>(uiData);
   \   00000100   018C               MOVW    R17:R16, R25:R24
   \   00000102   01F3               MOVW    R31:R30, R7:R6
   \   00000104   0DE2               ADD     R30, R2
   \   00000106   1DF3               ADC     R31, R3
   \   00000108   8300               ST      Z, R16
    186                  // Адрес следующего байта для сохранения.
    187                  // Увеличим количество закодированных байт.
    188                  uiEncodedByteCounter++;
   \   0000010A   E001               LDI     R16, 1
   \   0000010C   0E20               ADD     R2, R16
   \   0000010E   E000               LDI     R16, 0
   \   00000110   1E30               ADC     R3, R16
    189                  uiData >>= 8;
   \   00000112   2F89               MOV     R24, R25
   \   00000114   2F9A               MOV     R25, R26
   \   00000116   2FAB               MOV     R26, R27
   \   00000118   E0B0               LDI     R27, 0
    190                  puiDestination[uiEncodedByteCounter] = static_cast<uint8_t>(uiData);
   \   0000011A   018C               MOVW    R17:R16, R25:R24
   \   0000011C   01F3               MOVW    R31:R30, R7:R6
   \   0000011E   0DE2               ADD     R30, R2
   \   00000120   1DF3               ADC     R31, R3
   \   00000122   8300               ST      Z, R16
    191                  // Адрес следующего байта для сохранения.
    192                  // Увеличим количество закодированных байт.
    193                  uiEncodedByteCounter++;
   \   00000124   E001               LDI     R16, 1
   \   00000126   0E20               ADD     R2, R16
   \   00000128   E000               LDI     R16, 0
   \   0000012A   1E30               ADC     R3, R16
    194                  uiData >>= 8;
   \   0000012C   2F89               MOV     R24, R25
   \   0000012E   2F9A               MOV     R25, R26
   \   00000130   2FAB               MOV     R26, R27
   \   00000132   E0B0               LDI     R27, 0
    195                  puiDestination[uiEncodedByteCounter] = static_cast<uint8_t>(uiData);
   \   00000134   018C               MOVW    R17:R16, R25:R24
   \   00000136   01F3               MOVW    R31:R30, R7:R6
   \   00000138   0DE2               ADD     R30, R2
   \   0000013A   1DF3               ADC     R31, R3
   \   0000013C   8300               ST      Z, R16
    196                  // Адрес следующего байта для сохранения.
    197                  // Увеличим количество закодированных байт.
    198                  uiEncodedByteCounter++;
   \   0000013E   E001               LDI     R16, 1
   \   00000140   0E20               ADD     R2, R16
   \   00000142   E000               LDI     R16, 0
   \   00000144   1E30               ADC     R3, R16
    199              }
    200          
    201              return uiEncodedByteCounter;
   \                     ??BytesToHammingCodes_4:
   \   00000146   0181               MOVW    R17:R16, R3:R2
   \   00000148   E0EF               LDI     R30, 15
   \   0000014A   ........           JMP     ?EPILOGUE_B15_L09
    202          }
    203          
    204          //-----------------------------------------------------------------------------------------------------
    205          // Декодирует буфер с кодом Хемминга.

   \                                 In  segment CODE, align 2, keep-with-next
    206          uint16_t CHammingCodes::HammingCodesToBytes(uint8_t* puiDestination, uint8_t* puiSource, uint16_t uiEncodedLength)
   \                     ??HammingCodesToBytes:
    207          {
   \   00000000   ........           CALL    ?PROLOGUE16_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R9_is_cg_reg
   \   00000004                      REQUIRE ?Register_R10_is_cg_reg
   \   00000004                      REQUIRE ?Register_R11_is_cg_reg
   \   00000004                      REQUIRE ?Register_R12_is_cg_reg
   \   00000004                      REQUIRE ?Register_R13_is_cg_reg
   \   00000004                      REQUIRE ?Register_R14_is_cg_reg
   \   00000004                      REQUIRE ?Register_R15_is_cg_reg
   \   00000004   0158               MOVW    R11:R10, R17:R16
   \   00000006   0149               MOVW    R9:R8, R19:R18
   \   00000008   017A               MOVW    R15:R14, R21:R20
    208              uint16_t uiDecodedByteCounter = 0;
   \   0000000A   2466               CLR     R6
   \   0000000C   2477               CLR     R7
    209              uint16_t uiSourceIndex = 0;
   \   0000000E   2444               CLR     R4
   \   00000010   2455               CLR     R5
    210          //    bool bTailIsPresent = false;
    211          
    212              // uiEncodedLength = (uiLength * 1.5) (HammingCodes 8 + 4 на один байт приходится 12 закодированных бит - всегда кратно трём).
    213              // Длина закодированных данных не кратно трём?
    214              if ((uiEncodedLength > 0) && (uiEncodedLength % 3) != 0)
   \   00000012   2D0E               MOV     R16, R14
   \   00000014   290F               OR      R16, R15
   \   00000016   F051               BREQ    ??HammingCodesToBytes_1
   \   00000018   E043               LDI     R20, 3
   \   0000001A   E050               LDI     R21, 0
   \   0000001C   0187               MOVW    R17:R16, R15:R14
   \   0000001E   ........           CALL    ?US_DIVMOD_L02
   \   00000022   2B45               OR      R20, R21
   \   00000024   F019               BREQ    ??HammingCodesToBytes_1
    215              {
    216                  // Ошибка - не достаточно данных для восстановления.
    217                  return 0;
   \   00000026   E000               LDI     R16, 0
   \   00000028   E010               LDI     R17, 0
   \   0000002A   C057               RJMP    ??HammingCodesToBytes_2
    218              }
    219          
    220          //    // Количество байт данных нечётное?
    221          //    if ((uiEncodedLength % 3) == 2)
    222          //    {
    223          //        uiEncodedLength -= 2;
    224          //        bTailIsPresent = true;
    225          //    }
    226          
    227              // Декодируем все данные.
    228              for (uint16_t i = 0; i < uiEncodedLength; i += 3)
   \                     ??HammingCodesToBytes_1:
   \   0000002C   24CC               CLR     R12
   \   0000002E   24DD               CLR     R13
   \                     ??HammingCodesToBytes_3:
   \   00000030   14CE               CP      R12, R14
   \   00000032   04DF               CPC     R13, R15
   \   00000034   F008               BRCS    $+2+2
   \   00000036   C050               RJMP    ??HammingCodesToBytes_4
    229              {
    230                  uint32_t uiData;
    231          
    232                  uiData = (static_cast<uint32_t>(puiSource[uiSourceIndex]));
   \   00000038   01F4               MOVW    R31:R30, R9:R8
   \   0000003A   0DE4               ADD     R30, R4
   \   0000003C   1DF5               ADC     R31, R5
   \   0000003E   8100               LD      R16, Z
   \   00000040   E010               LDI     R17, 0
   \   00000042   E020               LDI     R18, 0
   \   00000044   E030               LDI     R19, 0
   \   00000046   01C8               MOVW    R25:R24, R17:R16
   \   00000048   01D9               MOVW    R27:R26, R19:R18
    233                  // Следующий байт источника.
    234                  uiSourceIndex++;
   \   0000004A   E001               LDI     R16, 1
   \   0000004C   0E40               ADD     R4, R16
   \   0000004E   E000               LDI     R16, 0
   \   00000050   1E50               ADC     R5, R16
    235                  uiData |= (static_cast<uint32_t>(puiSource[uiSourceIndex]) << 8);
   \   00000052   01F4               MOVW    R31:R30, R9:R8
   \   00000054   0DE4               ADD     R30, R4
   \   00000056   1DF5               ADC     R31, R5
   \   00000058   8100               LD      R16, Z
   \   0000005A   E010               LDI     R17, 0
   \   0000005C   E020               LDI     R18, 0
   \   0000005E   E030               LDI     R19, 0
   \   00000060   2F32               MOV     R19, R18
   \   00000062   2F21               MOV     R18, R17
   \   00000064   2F10               MOV     R17, R16
   \   00000066   E000               LDI     R16, 0
   \   00000068   2B80               OR      R24, R16
   \   0000006A   2B91               OR      R25, R17
   \   0000006C   2BA2               OR      R26, R18
   \   0000006E   2BB3               OR      R27, R19
    236                  // Следующий байт источника.
    237                  uiSourceIndex++;
   \   00000070   E001               LDI     R16, 1
   \   00000072   0E40               ADD     R4, R16
   \   00000074   E000               LDI     R16, 0
   \   00000076   1E50               ADC     R5, R16
    238                  uiData |= (static_cast<uint32_t>(puiSource[uiSourceIndex]) << 16);
   \   00000078   01F4               MOVW    R31:R30, R9:R8
   \   0000007A   0DE4               ADD     R30, R4
   \   0000007C   1DF5               ADC     R31, R5
   \   0000007E   8120               LD      R18, Z
   \   00000080   E030               LDI     R19, 0
   \   00000082   E000               LDI     R16, 0
   \   00000084   E010               LDI     R17, 0
   \   00000086   2B80               OR      R24, R16
   \   00000088   2B91               OR      R25, R17
   \   0000008A   2BA2               OR      R26, R18
   \   0000008C   2BB3               OR      R27, R19
    239                  // Следующий байт источника.
    240                  uiSourceIndex++;
   \   0000008E   E001               LDI     R16, 1
   \   00000090   0E40               ADD     R4, R16
   \   00000092   E000               LDI     R16, 0
   \   00000094   1E50               ADC     R5, R16
    241          
    242                  // Восстановим закодированный байт.
    243                  puiDestination[uiDecodedByteCounter] = Recovery((static_cast<uint16_t>(uiData) & 0x0FFF));
   \   00000096   018C               MOVW    R17:R16, R25:R24
   \   00000098   7F0F               ANDI    R16, 0xFF
   \   0000009A   701F               ANDI    R17, 0x0F
   \   0000009C   ....               RCALL   ??Recovery
   \   0000009E   01F5               MOVW    R31:R30, R11:R10
   \   000000A0   0DE6               ADD     R30, R6
   \   000000A2   1DF7               ADC     R31, R7
   \   000000A4   8300               ST      Z, R16
    244                  // Увеличим количество декодированных байт.
    245                  uiDecodedByteCounter++;
   \   000000A6   E001               LDI     R16, 1
   \   000000A8   0E60               ADD     R6, R16
   \   000000AA   E000               LDI     R16, 0
   \   000000AC   1E70               ADC     R7, R16
    246                  // Восстановим закодированный байт.
    247                  puiDestination[uiDecodedByteCounter] = Recovery((static_cast<uint16_t>(uiData >> HAMMING_CODE_8_4_BIT_NUMBER) & 0x0FFF));
   \   000000AE   E04C               LDI     R20, 12
   \   000000B0   018C               MOVW    R17:R16, R25:R24
   \   000000B2   019D               MOVW    R19:R18, R27:R26
   \   000000B4   ........           CALL    ?UL_SHR_L03
   \   000000B8   7F0F               ANDI    R16, 0xFF
   \   000000BA   701F               ANDI    R17, 0x0F
   \   000000BC   ....               RCALL   ??Recovery
   \   000000BE   01F5               MOVW    R31:R30, R11:R10
   \   000000C0   0DE6               ADD     R30, R6
   \   000000C2   1DF7               ADC     R31, R7
   \   000000C4   8300               ST      Z, R16
    248                  // Увеличим количество декодированных байт.
    249                  uiDecodedByteCounter++;
   \   000000C6   E001               LDI     R16, 1
   \   000000C8   0E60               ADD     R6, R16
   \   000000CA   E000               LDI     R16, 0
   \   000000CC   1E70               ADC     R7, R16
    250              }
   \   000000CE   E003               LDI     R16, 3
   \   000000D0   0EC0               ADD     R12, R16
   \   000000D2   E000               LDI     R16, 0
   \   000000D4   1ED0               ADC     R13, R16
   \   000000D6   CFAC               RJMP    ??HammingCodesToBytes_3
    251          
    252          //    if (bTailIsPresent)
    253          //    {
    254          //        uint16_t uiData;
    255          //
    256          //        uiData = (static_cast<uint16_t>(puiSource[uiSourceIndex]));
    257          //        // Следующий байт источника.
    258          //        uiSourceIndex++;
    259          //        uiData |= (static_cast<uint16_t>(puiSource[uiSourceIndex]) << 8);
    260          //
    261          //        // Восстановим закодированный байт.
    262          //        puiDestination[uiDecodedByteCounter] = Recovery(uiData & 0x0FFF);
    263          //        // Увеличим количество декодированных байт.
    264          //        uiDecodedByteCounter++;
    265          //    }
    266          
    267              return uiDecodedByteCounter;
   \                     ??HammingCodesToBytes_4:
   \   000000D8   0183               MOVW    R17:R16, R7:R6
   \                     ??HammingCodesToBytes_2:
   \   000000DA   E1E0               LDI     R30, 16
   \   000000DC   ........           JMP     ?EPILOGUE_B16_L09
    268          }
    269          
    270          //-----------------------------------------------------------------------------------------------------

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
     15      2   CHammingCodes::BytesToHammingCodes(uint8_t *, uint8_t *, uint16_t)
       15      2   -> CHammingCodes::enHamming(uint8_t)
       15      2 ?L_SHL_L03
      0      2   CHammingCodes::CalculateEncodedDataLength(uint16_t)
     16      2   CHammingCodes::HammingCodesToBytes(uint8_t *, uint8_t *, uint16_t)
       16      2   -> CHammingCodes::Recovery(uint16_t)
       16      2 ?UL_SHR_L03
       16      2 ?US_DIVMOD_L02
      0      2   CHammingCodes::Recovery(uint16_t)
        0      2   -> CHammingCodes::deHamming(uint16_t)
        0      2   -> CHammingCodes::findHammingError(uint16_t)
        0      2   -> CHammingCodes::fixError(uint16_t, uint8_t)
      0      2   CHammingCodes::deHamming(uint16_t)
        0      2 ?US_SHR_L02
      0      2   CHammingCodes::enHamming(uint8_t)
        0      2   -> CHammingCodes::getEvenParityforTx(uint8_t)
      0      2   CHammingCodes::findHammingError(uint16_t)
        0      2   -> CHammingCodes::getEvenParityforRx(uint16_t)
      0      2   CHammingCodes::fixError(uint16_t, uint8_t)
        0      2 ?S_SHL_L02
      0      2   CHammingCodes::getEvenParityforRx(uint16_t)
        0      2 ?US_SHR_L02
      0      2   CHammingCodes::getEvenParityforTx(uint8_t)
        0      2 ?SS_SHR_L02


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     334  CHammingCodes::BytesToHammingCodes(uint8_t *, uint8_t *, uint16_t)
      20  CHammingCodes::CalculateEncodedDataLength(uint16_t)
     224  CHammingCodes::HammingCodesToBytes(uint8_t *, uint8_t *, uint16_t)
      16  CHammingCodes::Recovery(uint16_t)
      42  CHammingCodes::deHamming(uint16_t)
     106  CHammingCodes::enHamming(uint8_t)
     126  CHammingCodes::findHammingError(uint16_t)
      34  CHammingCodes::fixError(uint16_t, uint8_t)
      44  CHammingCodes::getEvenParityforRx(uint16_t)
      46  CHammingCodes::getEvenParityforTx(uint8_t)
       1  CHammingCodes::m_uiErrorCode
       7  -- Other

 
 992 bytes in segment CODE
   7 bytes in segment INITTAB
   1 byte  in segment NEAR_Z
 
 992 bytes of CODE memory (+ 7 bytes shared)
   1 byte  of DATA memory

Errors: none
Warnings: none

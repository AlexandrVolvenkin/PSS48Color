///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.10.6.1378 for Atmel AVR          12/Oct/2024  21:32:34
// Copyright 1996-2018 IAR Systems AB.
//
//    Source file  =  
//        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\src\DataStore.cpp
//    Command line =  
//        -f C:\Users\Admin\AppData\Local\Temp\EWDA40.tmp
//        (--string_literals_in_flash
//        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\src\DataStore.cpp
//        --cpu=m128a -ms -o
//        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\Obj -lC
//        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\List -lB
//        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\List -y
//        --initializers_in_flash --root_variables --no_cse --no_inline
//        --no_code_motion --no_cross_call --no_clustering --no_tbaa --debug
//        -DENABLE_BIT_DEFINITIONS -e -I
//        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Modbus\ -I
//        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\include\
//        --eeprom_size 4096 --dlib --dlib_config "C:\Program Files (x86)\IAR
//        Systems\Embedded Workbench 8.0\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On
//        --eec++)
//    Locale       =  Russian_RUS.1251
//    List file    =  
//        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\List\DataStore.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME DataStore

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        ERROR
//NOTE: This module defines or uses C++ features that are not
//      accessible from assembler code. Assembling this file will
//      not produce an equivalent object file to the one produced
//      by the C++ compiler.

        EXTERN ?EPILOGUE_B10_L09
        EXTERN ?EPILOGUE_B14_L09
        EXTERN ?EPILOGUE_B3_L09
        EXTERN ?EPILOGUE_B4_L09
        EXTERN ?EPILOGUE_B5_L09
        EXTERN ?PROLOGUE10_L09
        EXTERN ?PROLOGUE14_L09
        EXTERN ?PROLOGUE3_L09
        EXTERN ?PROLOGUE4_L09
        EXTERN ?PROLOGUE5_L09
        EXTERN ?Register_R10_is_cg_reg
        EXTERN ?Register_R11_is_cg_reg
        EXTERN ?Register_R12_is_cg_reg
        EXTERN ?Register_R13_is_cg_reg
        EXTERN ?Register_R4_is_cg_reg
        EXTERN ?Register_R5_is_cg_reg
        EXTERN ?Register_R6_is_cg_reg
        EXTERN ?Register_R7_is_cg_reg
        EXTERN ?Register_R8_is_cg_reg
        EXTERN ?Register_R9_is_cg_reg
        EXTERN ?S_EC_MUL_L02
        EXTERN ?call_ctors
        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_I>`
        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBLIC ??Check
        PUBLIC ??CompareCurrentWithStoredCrc
        PUBLIC ??CrcOfBlocksCrcCheck
        PUBLIC ??CrcOfBlocksCrcCreate
        PUBLIC ??Fsm
        PUBWEAK ??GetBufferIsWrited
        PUBWEAK ??GetErrorCode
        PUBWEAK ??GetFsmEvent
        PUBWEAK ??GetFsmState
        PUBWEAK ??GetTimerPointer
        PUBLIC ??Init
        PUBWEAK ??IsReadyToWrite
        PUBLIC ??ReadBlock
        PUBLIC ??ReadBlockFlash
        PUBWEAK ??ReadyInterruptEnable
        PUBWEAK ??SetBufferIsWrited
        PUBWEAK ??SetErrorCode
        PUBWEAK ??SetErrorCode_1
        PUBWEAK ??SetFsmEvent
        PUBWEAK ??SetFsmState
        PUBWEAK ??StartWrite
        PUBWEAK ??WatchdogReset
        PUBLIC ??Write
        PUBLIC ??WriteBlock
        PUBLIC ??m_auiBlocksCurrentCrc
        PUBLIC ??m_puiIntermediateBuff
        PUBLIC ??m_uiFsmEvent
        PUBLIC ??m_uiFsmState
        PUBLIC ??m_xBlocksControlData
        PUBLIC ??m_xTimer
        PUBWEAK _A_ACSR
        PUBWEAK _A_ADC
        PUBWEAK _A_ADCSRA
        PUBWEAK _A_ADMUX
        PUBWEAK _A_ASSR
        PUBWEAK _A_DDRA
        PUBWEAK _A_DDRB
        PUBWEAK _A_DDRC
        PUBWEAK _A_DDRD
        PUBWEAK _A_DDRE
        PUBWEAK _A_DDRF
        PUBWEAK _A_DDRG
        PUBWEAK _A_EEAR
        PUBWEAK _A_EECR
        PUBWEAK _A_EEDR
        PUBWEAK _A_EICRA
        PUBWEAK _A_EICRB
        PUBWEAK _A_EIFR
        PUBWEAK _A_EIMSK
        PUBWEAK _A_ETIFR
        PUBWEAK _A_ETIMSK
        PUBWEAK _A_ICR1
        PUBWEAK _A_ICR3
        PUBWEAK _A_MCUCR
        PUBWEAK _A_MCUCSR
        PUBWEAK _A_OCDR
        PUBWEAK _A_OCR0
        PUBWEAK _A_OCR1A
        PUBWEAK _A_OCR1B
        PUBWEAK _A_OCR1C
        PUBWEAK _A_OCR2
        PUBWEAK _A_OCR3A
        PUBWEAK _A_OCR3B
        PUBWEAK _A_OCR3C
        PUBWEAK _A_OSCCAL
        PUBWEAK _A_PINA
        PUBWEAK _A_PINB
        PUBWEAK _A_PINC
        PUBWEAK _A_PIND
        PUBWEAK _A_PINE
        PUBWEAK _A_PINF
        PUBWEAK _A_PING
        PUBWEAK _A_PORTA
        PUBWEAK _A_PORTB
        PUBWEAK _A_PORTC
        PUBWEAK _A_PORTD
        PUBWEAK _A_PORTE
        PUBWEAK _A_PORTF
        PUBWEAK _A_PORTG
        PUBWEAK _A_RAMPZ
        PUBWEAK _A_SFIOR
        PUBWEAK _A_SP
        PUBWEAK _A_SPCR
        PUBWEAK _A_SPDR
        PUBWEAK _A_SPMCSR
        PUBWEAK _A_SPSR
        PUBWEAK _A_SREG
        PUBWEAK _A_TCCR0
        PUBWEAK _A_TCCR1A
        PUBWEAK _A_TCCR1B
        PUBWEAK _A_TCCR1C
        PUBWEAK _A_TCCR2
        PUBWEAK _A_TCCR3A
        PUBWEAK _A_TCCR3B
        PUBWEAK _A_TCCR3C
        PUBWEAK _A_TCNT0
        PUBWEAK _A_TCNT1
        PUBWEAK _A_TCNT2
        PUBWEAK _A_TCNT3
        PUBWEAK _A_TIFR
        PUBWEAK _A_TIMSK
        PUBWEAK _A_TWAR
        PUBWEAK _A_TWBR
        PUBWEAK _A_TWCR
        PUBWEAK _A_TWDR
        PUBWEAK _A_TWSR
        PUBWEAK _A_UBRR0H
        PUBWEAK _A_UBRR0L
        PUBWEAK _A_UBRR1H
        PUBWEAK _A_UBRR1L
        PUBWEAK _A_UCSR0A
        PUBWEAK _A_UCSR0B
        PUBWEAK _A_UCSR0C
        PUBWEAK _A_UCSR1A
        PUBWEAK _A_UCSR1B
        PUBWEAK _A_UCSR1C
        PUBWEAK _A_UDR0
        PUBWEAK _A_UDR1
        PUBWEAK _A_WDTCR
        PUBWEAK _A_XDIV
        PUBWEAK _A_XMCRA
        PUBWEAK _A_XMCRB
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR

`?<Name CHammingCodes 0>` SYMBOL "CHammingCodes"
`?<Name CEeprom 19>` SYMBOL "CEeprom"
`?<Name CPss21 31>` SYMBOL "CPss21"
??m_auiIntermediateBuff SYMBOL "m_auiIntermediateBuff", `?<Name CPss21 31>`
??m_bBufferIsWrited SYMBOL "m_bBufferIsWrited", `?<Name CEeprom 19>`
??m_uiErrorCode     SYMBOL "m_uiErrorCode", `?<Name CPss21 31>`
??m_uiErrorCode_1   SYMBOL "m_uiErrorCode", `?<Name CHammingCodes 0>`
`?<Name CDataStore 43>` SYMBOL "CDataStore"
??m_auiBlocksCurrentCrc SYMBOL "m_auiBlocksCurrentCrc", `?<Name CDataStore 43>`
??m_puiIntermediateBuff SYMBOL "m_puiIntermediateBuff", `?<Name CDataStore 43>`
??m_uiFsmEvent      SYMBOL "m_uiFsmEvent", `?<Name CDataStore 43>`
??m_uiFsmState      SYMBOL "m_uiFsmState", `?<Name CDataStore 43>`
??m_xBlocksControlData SYMBOL "m_xBlocksControlData", `?<Name CDataStore 43>`
??m_xTimer          SYMBOL "m_xTimer", `?<Name CDataStore 43>`

        EXTERN ??BytesToHammingCodes
        EXTERN ??CTimer
        EXTERN ??CalculateEncodedDataLength
        EXTERN ??HammingCodesToBytes
        EXTERN ??IsOverflow
        EXTERN ??Read
        EXTERN ??ReadBlock_6
        EXTERN ??Set
        EXTERN ??WriteInterrupt
        EXTERN ??delay_ms
        EXTERN ??m_auiIntermediateBuff
        EXTERN ??m_bBufferIsWrited
        EXTERN ??m_uiErrorCode
        EXTERN ??m_uiErrorCode_1
        EXTERN ??usCrc16
        EXTERN `?~CTimer`
        EXTERN __record_needed_destruction
        EXTERN memcpy
        EXTERN memset

// D:\Projects\CurrentProjects\CautoProjects\PSS48Color\src\DataStore.cpp
//    1 
//    2 //-----------------------------------------------------------------------------------------------------
//    3 //  Source      : FileName.cpp
//    4 //  Created     : 01.06.2022
//    5 //  Author      : Alexandr Volvenkin
//    6 //  email       : aav-36@mail.ru
//    7 //  GitHub      : https://github.com/AlexandrVolvenkin
//    8 //-----------------------------------------------------------------------------------------------------
//    9 #include "DataStore.h"

        ASEGN ABSOLUTE:DATA:ROOT,09dH
// union <unnamed> volatile __io _A_UCSR1C
_A_UCSR1C:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,09cH
// union <unnamed> volatile __io _A_UDR1
_A_UDR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,09bH
// union <unnamed> volatile __io _A_UCSR1A
_A_UCSR1A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,09aH
// union <unnamed> volatile __io _A_UCSR1B
_A_UCSR1B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,099H
// union <unnamed> volatile __io _A_UBRR1L
_A_UBRR1L:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,098H
// union <unnamed> volatile __io _A_UBRR1H
_A_UBRR1H:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,095H
// union <unnamed> volatile __io _A_UCSR0C
_A_UCSR0C:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,090H
// union <unnamed> volatile __io _A_UBRR0H
_A_UBRR0H:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,08cH
// union <unnamed> volatile __io _A_TCCR3C
_A_TCCR3C:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,08bH
// union <unnamed> volatile __io _A_TCCR3A
_A_TCCR3A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,08aH
// union <unnamed> volatile __io _A_TCCR3B
_A_TCCR3B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,088H
// union <unnamed> volatile __io _A_TCNT3
_A_TCNT3:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,086H
// union <unnamed> volatile __io _A_OCR3A
_A_OCR3A:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,084H
// union <unnamed> volatile __io _A_OCR3B
_A_OCR3B:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,082H
// union <unnamed> volatile __io _A_OCR3C
_A_OCR3C:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,080H
// union <unnamed> volatile __io _A_ICR3
_A_ICR3:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,07dH
// union <unnamed> volatile __io _A_ETIMSK
_A_ETIMSK:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07cH
// union <unnamed> volatile __io _A_ETIFR
_A_ETIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07aH
// union <unnamed> volatile __io _A_TCCR1C
_A_TCCR1C:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,078H
// union <unnamed> volatile __io _A_OCR1C
_A_OCR1C:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,074H
// union <unnamed> volatile __io _A_TWCR
_A_TWCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,073H
// union <unnamed> volatile __io _A_TWDR
_A_TWDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,072H
// union <unnamed> volatile __io _A_TWAR
_A_TWAR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,071H
// union <unnamed> volatile __io _A_TWSR
_A_TWSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,070H
// union <unnamed> volatile __io _A_TWBR
_A_TWBR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06fH
// union <unnamed> volatile __io _A_OSCCAL
_A_OSCCAL:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06dH
// union <unnamed> volatile __io _A_XMCRA
_A_XMCRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06cH
// union <unnamed> volatile __io _A_XMCRB
_A_XMCRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06aH
// union <unnamed> volatile __io _A_EICRA
_A_EICRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,068H
// union <unnamed> volatile __io _A_SPMCSR
_A_SPMCSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,065H
// union <unnamed> volatile __io _A_PORTG
_A_PORTG:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,064H
// union <unnamed> volatile __io _A_DDRG
_A_DDRG:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,063H
// union <unnamed> volatile __io _A_PING
_A_PING:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,062H
// union <unnamed> volatile __io _A_PORTF
_A_PORTF:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,061H
// union <unnamed> volatile __io _A_DDRF
_A_DDRF:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,05fH
// union <unnamed> volatile __io _A_SREG
_A_SREG:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,05dH
// union <unnamed> volatile __io _A_SP
_A_SP:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,05cH
// union <unnamed> volatile __io _A_XDIV
_A_XDIV:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,05bH
// union <unnamed> volatile __io _A_RAMPZ
_A_RAMPZ:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,05aH
// union <unnamed> volatile __io _A_EICRB
_A_EICRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,059H
// union <unnamed> volatile __io _A_EIMSK
_A_EIMSK:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,058H
// union <unnamed> volatile __io _A_EIFR
_A_EIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,057H
// union <unnamed> volatile __io _A_TIMSK
_A_TIMSK:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,056H
// union <unnamed> volatile __io _A_TIFR
_A_TIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,055H
// union <unnamed> volatile __io _A_MCUCR
_A_MCUCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,054H
// union <unnamed> volatile __io _A_MCUCSR
_A_MCUCSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,053H
// union <unnamed> volatile __io _A_TCCR0
_A_TCCR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,052H
// union <unnamed> volatile __io _A_TCNT0
_A_TCNT0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,051H
// union <unnamed> volatile __io _A_OCR0
_A_OCR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,050H
// union <unnamed> volatile __io _A_ASSR
_A_ASSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04fH
// union <unnamed> volatile __io _A_TCCR1A
_A_TCCR1A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04eH
// union <unnamed> volatile __io _A_TCCR1B
_A_TCCR1B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04cH
// union <unnamed> volatile __io _A_TCNT1
_A_TCNT1:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,04aH
// union <unnamed> volatile __io _A_OCR1A
_A_OCR1A:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,048H
// union <unnamed> volatile __io _A_OCR1B
_A_OCR1B:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,046H
// union <unnamed> volatile __io _A_ICR1
_A_ICR1:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,045H
// union <unnamed> volatile __io _A_TCCR2
_A_TCCR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,044H
// union <unnamed> volatile __io _A_TCNT2
_A_TCNT2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,043H
// union <unnamed> volatile __io _A_OCR2
_A_OCR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,042H
// union <unnamed> volatile __io _A_OCDR
_A_OCDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,041H
// union <unnamed> volatile __io _A_WDTCR
_A_WDTCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,040H
// union <unnamed> volatile __io _A_SFIOR
_A_SFIOR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03eH
// union <unnamed> volatile __io _A_EEAR
_A_EEAR:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,03dH
// union <unnamed> volatile __io _A_EEDR
_A_EEDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03cH
// union <unnamed> volatile __io _A_EECR
_A_EECR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03bH
// union <unnamed> volatile __io _A_PORTA
_A_PORTA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03aH
// union <unnamed> volatile __io _A_DDRA
_A_DDRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,039H
// union <unnamed> volatile __io _A_PINA
_A_PINA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,038H
// union <unnamed> volatile __io _A_PORTB
_A_PORTB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,037H
// union <unnamed> volatile __io _A_DDRB
_A_DDRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,036H
// union <unnamed> volatile __io _A_PINB
_A_PINB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,035H
// union <unnamed> volatile __io _A_PORTC
_A_PORTC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,034H
// union <unnamed> volatile __io _A_DDRC
_A_DDRC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,033H
// union <unnamed> volatile __io _A_PINC
_A_PINC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,032H
// union <unnamed> volatile __io _A_PORTD
_A_PORTD:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,031H
// union <unnamed> volatile __io _A_DDRD
_A_DDRD:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,030H
// union <unnamed> volatile __io _A_PIND
_A_PIND:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02fH
// union <unnamed> volatile __io _A_SPDR
_A_SPDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02eH
// union <unnamed> volatile __io _A_SPSR
_A_SPSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02dH
// union <unnamed> volatile __io _A_SPCR
_A_SPCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02cH
// union <unnamed> volatile __io _A_UDR0
_A_UDR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02bH
// union <unnamed> volatile __io _A_UCSR0A
_A_UCSR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02aH
// union <unnamed> volatile __io _A_UCSR0B
_A_UCSR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,029H
// union <unnamed> volatile __io _A_UBRR0L
_A_UBRR0L:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,028H
// union <unnamed> volatile __io _A_ACSR
_A_ACSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,027H
// union <unnamed> volatile __io _A_ADMUX
_A_ADMUX:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,026H
// union <unnamed> volatile __io _A_ADCSRA
_A_ADCSRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,024H
// union <unnamed> volatile __io _A_ADC
_A_ADC:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,023H
// union <unnamed> volatile __io _A_PORTE
_A_PORTE:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,022H
// union <unnamed> volatile __io _A_DDRE
_A_DDRE:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,021H
// union <unnamed> volatile __io _A_PINE
_A_PINE:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,020H
// union <unnamed> volatile __io _A_PINF
_A_PINF:
        DS8 1
//   10 #include "Platform.h"
//   11 #include "Pss21.h"
//   12 #include "Crc.h"
//   13 #include "HammingCodes.h"
//   14 
//   15 
//   16 // Служебные данные системы хранения.

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   17 CDataStore::TBlocksControlData CDataStore::m_xBlocksControlData;
??m_xBlocksControlData:
        DS8 108
//   18 // Массив контрольных сумм блоков.

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   19 uint16_t CDataStore::m_auiBlocksCurrentCrc[MAX_BLOCKS_NUMBER];
??m_auiBlocksCurrentCrc:
        DS8 26

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   20 uint8_t* CDataStore::m_puiIntermediateBuff;
??m_puiIntermediateBuff:
        DS8 2

        RSEG NEAR_I:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
//   21 CTimer CDataStore::m_xTimer;
?_0:
        DS8 6
        REQUIRE `?<Initializer for >`

        RSEG CODE:CODE:NOROOT(1)
// static __intrinsic __version_3 void __sti__routine()
??__sti__routine:
        LDI     R16, LOW(??m_xTimer)
        LDI     R17, (??m_xTimer) >> 8
        CALL    ??CTimer
        LDI     R16, LOW(?_0)
        LDI     R17, (?_0) >> 8
        CALL    __record_needed_destruction
        RET

        RSEG CODE:CODE:NOROOT(1)
`?<Unnamed 0>`:
        ST      -Y, R25
        ST      -Y, R24
        MOVW    R25:R24, R17:R16
        LDI     R18, 2
        LDI     R19, 0
        MOVW    R17:R16, R25:R24
        CALL    `?~CTimer`
        LD      R24, Y+
        LD      R25, Y+
        RET

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
??m_xTimer:
        DS8 6

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
?_1:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   22 uint8_t CDataStore::m_uiFsmState;
??m_uiFsmState:
        DS8 1

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   23 uint8_t CDataStore::m_uiFsmEvent;
??m_uiFsmEvent:
        DS8 1
//   24 
//   25 ////-----------------------------------------------------------------------------------------------------
//   26 //CDataStore::CDataStore()
//   27 //{
//   28 ////    m_pxStorageDevice = new CEeprom();
//   29 //    m_puiIntermediateBuff = CPss21::m_auiIntermediateBuff;
//   30 //    SetFsmState(IDDLE);
//   31 //    SetSavedFsmState(IDDLE);
//   32 //}
//   33 //
//   34 ////-----------------------------------------------------------------------------------------------------
//   35 //CDataStore::~CDataStore()
//   36 //{
//   37 ////    delete m_pxStorageDevice;
//   38 //}
//   39 
//   40 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   41 void CDataStore::Init(void)
??Init:
//   42 {
//   43     m_puiIntermediateBuff = CPss21::m_auiIntermediateBuff;
        LDI     R16, LOW(??m_auiIntermediateBuff)
        LDI     R17, (??m_auiIntermediateBuff) >> 8
        LDI     R30, LOW(??m_puiIntermediateBuff)
        LDI     R31, (??m_puiIntermediateBuff) >> 8
        ST      Z, R16
        STD     Z+1, R17
//   44     SetFsmState(IDDLE);
        LDI     R16, 0
        CALL    ??SetFsmState
//   45 
//   46     // Очистим служебный контекст.
//   47     memset(reinterpret_cast<uint8_t*>(&m_xBlocksControlData),
//   48            0,
//   49            sizeof(m_xBlocksControlData));
        LDI     R20, 108
        LDI     R21, 0
        LDI     R18, 0
        LDI     R19, 0
        LDI     R16, LOW(??m_xBlocksControlData)
        LDI     R17, (??m_xBlocksControlData) >> 8
        CALL    memset
//   50 
//   51     // Установим смещение на закодированные данные.
//   52     m_xBlocksControlData.
//   53     axBlockPositionData[BLOCKS_CONTROL_DATA].uiOffset = BLOCKS_CONTROL_DATA_BEGIN;
        LDI     R30, LOW(??m_xBlocksControlData)
        LDI     R31, (??m_xBlocksControlData) >> 8
        LDI     R16, 16
        LDI     R17, 0
        STD     Z+4, R16
        STD     Z+5, R17
//   54     // Установим размер первичных данных.
//   55     m_xBlocksControlData.
//   56     axBlockPositionData[BLOCKS_CONTROL_DATA].uiLength = sizeof(struct TBlocksControlData);
        LDI     R30, LOW(??m_xBlocksControlData)
        LDI     R31, (??m_xBlocksControlData) >> 8
        LDI     R16, 108
        LDI     R17, 0
        STD     Z+6, R16
        STD     Z+7, R17
//   57     // Количество байт служебного контекста
//   58     // должно быть известно заранее.
//   59     // Так как по нему извлекаются начальные данные.
//   60     // Используется самовосстанавливающийся код Хемминга(8,4).
//   61     // Коэффициент - 1.5: один байт преобразуется в кодовое слово 12 бит,
//   62     // из двух байт полезных данных получается три байта кодированных.
//   63     // Установим размер закодированных данных.
//   64     m_xBlocksControlData.
//   65     axBlockPositionData[BLOCKS_CONTROL_DATA].uiEncodedLength =
//   66         (CHammingCodes::CalculateEncodedDataLength(sizeof(struct TBlocksControlData) + CRC_LENGTH));
        LDI     R16, 110
        LDI     R17, 0
        CALL    ??CalculateEncodedDataLength
        LDI     R30, LOW(??m_xBlocksControlData)
        LDI     R31, (??m_xBlocksControlData) >> 8
        STD     Z+8, R16
        STD     Z+9, R17
//   67     // Установим смещение для служебного контекста.
//   68     m_xBlocksControlData.uiFreeSpaceOffset =
//   69         (BLOCKS_CONTROL_DATA_BEGIN +
//   70          CHammingCodes::CalculateEncodedDataLength(sizeof(struct TBlocksControlData) + CRC_LENGTH));
        LDI     R16, 110
        LDI     R17, 0
        CALL    ??CalculateEncodedDataLength
        SUBI    R16, 240
        SBCI    R17, 255
        LDI     R30, LOW(??m_xBlocksControlData)
        LDI     R31, (??m_xBlocksControlData) >> 8
        STD     Z+2, R16
        STD     Z+3, R17
//   71     // Установим признак - база данных не подтверждена пользователем.
//   72     m_xBlocksControlData.uiCrcOfBlocksCrc = 0;
        LDI     R30, LOW(??m_xBlocksControlData)
        LDI     R31, (??m_xBlocksControlData) >> 8
        LDI     R16, 0
        ST      Z, R16
        LDI     R16, 0
        STD     Z+1, R16
//   73 }
        RET
//   74 
//   75 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   76 uint16_t CDataStore::ReadBlock(uint8_t *puiDestination, uint8_t uiBlock)
??ReadBlock:
//   77 {
        CALL    ?PROLOGUE14_L09
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R6_is_cg_reg
        REQUIRE ?Register_R7_is_cg_reg
        REQUIRE ?Register_R8_is_cg_reg
        REQUIRE ?Register_R10_is_cg_reg
        REQUIRE ?Register_R11_is_cg_reg
        REQUIRE ?Register_R12_is_cg_reg
        REQUIRE ?Register_R13_is_cg_reg
        SUBI    R29, 1
        MOVW    R7:R6, R17:R16
        MOV     R8, R18
//   78     // Произошёл выход за границы буфера?
//   79     if (uiBlock >= MAX_BLOCKS_NUMBER)
        LDI     R16, 13
        CP      R8, R16
        BRCS    ??ReadBlock_1
//   80     {
//   81         // Нет данных.
//   82         return 0;
        LDI     R16, 0
        LDI     R17, 0
        RJMP    ??ReadBlock_2
//   83     }
//   84 
//   85     uint16_t uiLength;
//   86     uint16_t uiEncodedLength;
//   87     uint16_t uiSourceOffset;
//   88     uint8_t auiTempArray[256];
//   89 
//   90     // Блок существует?
//   91     if ((m_xBlocksControlData.
//   92             axBlockPositionData[uiBlock].uiLength != 0) &&
//   93             (m_xBlocksControlData.
//   94              axBlockPositionData[uiBlock].uiEncodedLength != 0))
??ReadBlock_1:
        MOV     R16, R8
        LDI     R17, 0
        LDI     R20, 8
        LDI     R21, 0
        CALL    ?S_EC_MUL_L02
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
        SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
        LDD     R16, Z+6
        LDD     R17, Z+7
        OR      R16, R17
        BRNE    $+2+2
        RJMP    ??ReadBlock_3
        MOV     R16, R8
        LDI     R17, 0
        LDI     R20, 8
        LDI     R21, 0
        CALL    ?S_EC_MUL_L02
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
        SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
        LDD     R16, Z+8
        LDD     R17, Z+9
        OR      R16, R17
        BRNE    $+2+2
        RJMP    ??ReadBlock_3
//   95     {
//   96         // Получим адрес блока в EEPROM.
//   97         uiSourceOffset = m_xBlocksControlData.
//   98                          axBlockPositionData[uiBlock].uiOffset;
        MOV     R16, R8
        LDI     R17, 0
        LDI     R20, 8
        LDI     R21, 0
        CALL    ?S_EC_MUL_L02
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
        SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
        LDD     R16, Z+4
        LDD     R17, Z+5
        MOVW    R13:R12, R17:R16
//   99         // Получим размер блока.
//  100         uiLength = m_xBlocksControlData.
//  101                    axBlockPositionData[uiBlock].uiLength;
        MOV     R16, R8
        LDI     R17, 0
        LDI     R20, 8
        LDI     R21, 0
        CALL    ?S_EC_MUL_L02
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
        SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
        LDD     R16, Z+6
        LDD     R17, Z+7
        MOVW    R5:R4, R17:R16
//  102         // Получим размер закодированного блока.
//  103         uiEncodedLength = m_xBlocksControlData.
//  104                           axBlockPositionData[uiBlock].uiEncodedLength;
        MOV     R16, R8
        LDI     R17, 0
        LDI     R20, 8
        LDI     R21, 0
        CALL    ?S_EC_MUL_L02
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
        SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
        LDD     R16, Z+8
        LDD     R17, Z+9
        MOVW    R11:R10, R17:R16
//  105     }
//  106     else
//  107     {
//  108         // Нет данных.
//  109         return 0;
//  110     }
//  111 
//  112     // Прочитаем закодированные данные.
//  113     CEeprom::Read(auiTempArray, uiSourceOffset, uiEncodedLength);
        MOVW    R21:R20, R11:R10
        MOVW    R19:R18, R13:R12
        MOVW    R17:R16, R29:R28
        CALL    ??Read
//  114 
//  115     // Декодируем прочитанные данные.
//  116     CHammingCodes::HammingCodesToBytes(auiTempArray, auiTempArray, uiEncodedLength);
        MOVW    R21:R20, R11:R10
        MOVW    R19:R18, R29:R28
        MOVW    R17:R16, R29:R28
        CALL    ??HammingCodesToBytes
//  117 
//  118     // Получим контрольную сумму блока.
//  119     uint16_t uiCrc = static_cast<uint16_t>(auiTempArray[uiLength]);
        MOVW    R31:R30, R29:R28
        ADD     R30, R4
        ADC     R31, R5
        LD      R24, Z
        LDI     R25, 0
//  120     uiCrc |= (static_cast<uint16_t>(auiTempArray[uiLength + 1]) << 8);
        MOVW    R31:R30, R29:R28
        ADD     R30, R4
        ADC     R31, R5
        LDD     R17, Z+1
        LDI     R16, 0
        OR      R24, R16
        OR      R25, R17
//  121     // Вычислим контрольную сумму блока.
//  122     uint16_t uiCalculatedCrc = usCrc16(auiTempArray, uiLength);
        MOVW    R19:R18, R5:R4
        MOVW    R17:R16, R29:R28
        CALL    ??usCrc16
        MOVW    R27:R26, R17:R16
//  123 
//  124     // Блок не повреждён?
//  125     if (uiCrc == uiCalculatedCrc)
        CP      R24, R26
        CPC     R25, R27
        BRNE    ??ReadBlock_4
        RJMP    ??ReadBlock_5
??ReadBlock_3:
        LDI     R16, 0
        LDI     R17, 0
        RJMP    ??ReadBlock_2
//  126     {
//  127         // Сохраним Crc текущего блока.
//  128         m_auiBlocksCurrentCrc[uiBlock] = uiCrc;
??ReadBlock_5:
        MOV     R16, R8
        LDI     R17, 0
        LSL     R16
        ROL     R17
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(??m_auiBlocksCurrentCrc) & 0xFFFF))
        SBCI    R31, (-(??m_auiBlocksCurrentCrc) & 0xFFFF) >> 8
        ST      Z, R24
        STD     Z+1, R25
//  129         memcpy(puiDestination, auiTempArray, uiLength);
        MOVW    R21:R20, R5:R4
        MOVW    R19:R18, R29:R28
        MOVW    R17:R16, R7:R6
        CALL    memcpy
//  130         return uiLength;
        MOVW    R17:R16, R5:R4
        RJMP    ??ReadBlock_2
//  131     }
//  132     else
//  133     {
//  134         CPss21::SetErrorCode(DB_ERROR);
??ReadBlock_4:
        LDI     R16, 4
        CALL    ??SetErrorCode
//  135         // Нет данных.
//  136         return 0;
        LDI     R16, 0
        LDI     R17, 0
??ReadBlock_2:
        SUBI    R29, 255
        LDI     R30, 14
        JMP     ?EPILOGUE_B14_L09
//  137     }
//  138 }
//  139 
//  140 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  141 uint16_t CDataStore::Write(uint8_t *puiSource, uint16_t uiLength, uint8_t uiBlock)
??Write:
//  142 {
        CALL    ?PROLOGUE10_L09
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R6_is_cg_reg
        REQUIRE ?Register_R8_is_cg_reg
        REQUIRE ?Register_R9_is_cg_reg
        SUBI    R29, 1
        MOVW    R5:R4, R17:R16
        MOVW    R25:R24, R19:R18
        MOV     R6, R20
//  143     // Произошёл выход за границы буфера?
//  144     if (uiBlock >= MAX_BLOCKS_NUMBER)
        LDI     R16, 13
        CP      R6, R16
        BRCS    ??Write_1
//  145     {
//  146         // Нет данных.
//  147         return 0;
        LDI     R16, 0
        LDI     R17, 0
        RJMP    ??Write_2
//  148     }
//  149 
//  150     uint16_t uiEncodedByteCounter;
//  151     uint8_t auiTempArray[256];
//  152 
//  153     memcpy(auiTempArray, puiSource, uiLength);
??Write_1:
        MOVW    R21:R20, R25:R24
        MOVW    R19:R18, R5:R4
        MOVW    R17:R16, R29:R28
        CALL    memcpy
//  154     // Вычислим контрольную сумму поступивших данных.
//  155     uint16_t uiCrc = usCrc16(puiSource, uiLength);
        MOVW    R19:R18, R25:R24
        MOVW    R17:R16, R5:R4
        CALL    ??usCrc16
        MOVW    R27:R26, R17:R16
//  156     auiTempArray[uiLength] = static_cast<uint8_t>(uiCrc);
        MOV     R16, R26
        MOVW    R31:R30, R29:R28
        ADD     R30, R24
        ADC     R31, R25
        ST      Z, R16
//  157     auiTempArray[uiLength + 1] = static_cast<uint8_t>(uiCrc >> 8);
        MOVW    R17:R16, R27:R26
        MOV     R16, R17
        LDI     R17, 0
        MOVW    R31:R30, R29:R28
        ADD     R30, R24
        ADC     R31, R25
        STD     Z+1, R16
//  158 
//  159     m_xBlocksControlData.
//  160     axBlockPositionData[uiBlock].uiCrc = uiCrc;
        MOV     R16, R6
        LDI     R17, 0
        LDI     R20, 8
        LDI     R21, 0
        CALL    ?S_EC_MUL_L02
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
        SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
        STD     Z+10, R26
        STD     Z+11, R27
//  161 
//  162     uiEncodedByteCounter =
//  163         CHammingCodes::BytesToHammingCodes(m_puiIntermediateBuff, auiTempArray, (uiLength + CRC_LENGTH));
        MOVW    R21:R20, R25:R24
        SUBI    R20, 254
        SBCI    R21, 255
        MOVW    R19:R18, R29:R28
        LDI     R30, LOW(??m_puiIntermediateBuff)
        LDI     R31, (??m_puiIntermediateBuff) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        CALL    ??BytesToHammingCodes
        MOVW    R9:R8, R17:R16
//  164 
//  165     // Данные текущего блока данных - uiBlock сохраняются впервые?
//  166     if (m_xBlocksControlData.
//  167             axBlockPositionData[uiBlock].uiEncodedLength == 0)
        MOV     R16, R6
        LDI     R17, 0
        LDI     R20, 8
        LDI     R21, 0
        CALL    ?S_EC_MUL_L02
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
        SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
        LDD     R16, Z+8
        LDD     R17, Z+9
        OR      R16, R17
        BRNE    ??Write_3
//  168     {
//  169         // Добавили новый блок данных.
//  170         // Сохраним смещение на блок.
//  171         m_xBlocksControlData.
//  172         axBlockPositionData[uiBlock].uiOffset = m_xBlocksControlData.uiFreeSpaceOffset;
        LDI     R30, LOW(??m_xBlocksControlData)
        LDI     R31, (??m_xBlocksControlData) >> 8
        LDD     R18, Z+2
        LDD     R19, Z+3
        MOV     R16, R6
        LDI     R17, 0
        LDI     R20, 8
        LDI     R21, 0
        CALL    ?S_EC_MUL_L02
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
        SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
        STD     Z+4, R18
        STD     Z+5, R19
//  173         // Изменим смещение на свободное место.
//  174         m_xBlocksControlData.uiFreeSpaceOffset += uiEncodedByteCounter;
        LDI     R30, LOW(??m_xBlocksControlData)
        LDI     R31, (??m_xBlocksControlData) >> 8
        LDD     R16, Z+2
        LDD     R17, Z+3
        ADD     R16, R8
        ADC     R17, R9
        STD     Z+2, R16
        STD     Z+3, R17
//  175         // Сохраним размер первичных данных.
//  176         m_xBlocksControlData.
//  177         axBlockPositionData[uiBlock].uiLength = uiLength;
        MOV     R16, R6
        LDI     R17, 0
        LDI     R20, 8
        LDI     R21, 0
        CALL    ?S_EC_MUL_L02
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
        SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
        STD     Z+6, R24
        STD     Z+7, R25
//  178         // Сохраним размер закодированных данных.
//  179         m_xBlocksControlData.
//  180         axBlockPositionData[uiBlock].uiEncodedLength = uiEncodedByteCounter;
        MOV     R16, R6
        LDI     R17, 0
        LDI     R20, 8
        LDI     R21, 0
        CALL    ?S_EC_MUL_L02
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
        SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
        STD     Z+8, R8
        STD     Z+9, R9
//  181     }
//  182 
//  183     CEeprom::WriteInterrupt(m_xBlocksControlData.
//  184                             axBlockPositionData[uiBlock].uiOffset,
//  185                             m_puiIntermediateBuff,
//  186                             uiEncodedByteCounter);
??Write_3:
        MOVW    R21:R20, R9:R8
        LDI     R30, LOW(??m_puiIntermediateBuff)
        LDI     R31, (??m_puiIntermediateBuff) >> 8
        LD      R18, Z
        LDD     R19, Z+1
        MOVW    R23:R22, R21:R20
        MOV     R16, R6
        LDI     R17, 0
        LDI     R20, 8
        LDI     R21, 0
        CALL    ?S_EC_MUL_L02
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
        SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
        LDD     R16, Z+4
        LDD     R17, Z+5
        MOVW    R21:R20, R23:R22
        CALL    ??WriteInterrupt
//  187 
//  188     // Out length.
//  189     return uiEncodedByteCounter;
        MOVW    R17:R16, R9:R8
??Write_2:
        SUBI    R29, 255
        LDI     R30, 10
        JMP     ?EPILOGUE_B10_L09
//  190 }
//  191 
//  192 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  193 bool CDataStore::WriteBlock(uint8_t *puiSource, uint16_t uiLength, uint8_t uiBlock)
??WriteBlock:
//  194 {
        CALL    ?PROLOGUE5_L09
        REQUIRE ?Register_R4_is_cg_reg
        MOVW    R27:R26, R17:R16
        MOVW    R25:R24, R19:R18
        MOV     R4, R20
//  195     if (GetFsmState() == IDDLE)
        CALL    ??GetFsmState
        TST     R16
        BRNE    ??WriteBlock_1
//  196     {
//  197         if (Write(puiSource,
//  198                   uiLength,
//  199                   uiBlock))
        MOV     R20, R4
        MOVW    R19:R18, R25:R24
        MOVW    R17:R16, R27:R26
        RCALL   ??Write
        OR      R16, R17
        BREQ    ??WriteBlock_2
//  200         {
//  201             SetFsmEvent(WRITE_IN_PROGRESS_FSM_EVENT);
        LDI     R16, 1
        CALL    ??SetFsmEvent
//  202             SetFsmState(START_WRITE);
        LDI     R16, 1
        CALL    ??SetFsmState
//  203             return true;
        LDI     R16, 1
        RJMP    ??WriteBlock_3
//  204         }
//  205         else
//  206         {
//  207             SetFsmEvent(WRITE_ERROR_FSM_EVENT);
??WriteBlock_2:
        LDI     R16, 4
        CALL    ??SetFsmEvent
//  208             return false;
        LDI     R16, 0
        RJMP    ??WriteBlock_3
//  209         }
//  210     }
//  211     else
//  212     {
//  213         SetFsmEvent(STORAGE_DEVICE_BUSY_FSM_EVENT);
??WriteBlock_1:
        LDI     R16, 2
        CALL    ??SetFsmEvent
//  214         return false;
        LDI     R16, 0
??WriteBlock_3:
        LDI     R30, 5
        JMP     ?EPILOGUE_B5_L09
//  215     }
//  216 }
//  217 
//  218 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  219 bool CDataStore::CompareCurrentWithStoredCrc(void)
??CompareCurrentWithStoredCrc:
//  220 {
        MOVW    R23:R22, R27:R26
//  221     // Сравним текущее Crc блока с его Crc сохранённом в служебном блоке в предыдущей сессии записи.
//  222     for (uint16_t i = BLOCKS_CONTROL_DATA_BLOCK_NUMBER;
        LDI     R30, 1
        LDI     R31, 0
//  223             i < (MAX_BLOCKS_NUMBER - BLOCKS_CONTROL_DATA_BLOCK_NUMBER);
??CompareCurrentWithStoredCrc_1:
        CPI     R30, 12
        LDI     R16, 0
        CPC     R31, R16
        BRCC    ??CompareCurrentWithStoredCrc_2
//  224             i++)
//  225     {
//  226         if (m_auiBlocksCurrentCrc[i] !=
//  227                 m_xBlocksControlData.axBlockPositionData[i].uiCrc)
        MOVW    R17:R16, R31:R30
        LSL     R16
        ROL     R17
        MOVW    R27:R26, R17:R16
        SUBI    R26, LOW((-(??m_auiBlocksCurrentCrc) & 0xFFFF))
        SBCI    R27, (-(??m_auiBlocksCurrentCrc) & 0xFFFF) >> 8
        LD      R18, X+
        LD      R19, X
        SBIW    R27:R26, 1
        MOVW    R17:R16, R31:R30
        LDI     R20, 8
        LDI     R21, 0
        CALL    ?S_EC_MUL_L02
        MOVW    R27:R26, R17:R16
        SUBI    R26, LOW((-(??m_xBlocksControlData + 10) & 0xFFFF))
        SBCI    R27, HIGH((-(??m_xBlocksControlData + 10) & 0xFFFF))
        LD      R16, X+
        LD      R17, X
        SBIW    R27:R26, 1
        CP      R18, R16
        CPC     R19, R17
        BREQ    ??CompareCurrentWithStoredCrc_3
//  228         {
//  229             return false;
        LDI     R16, 0
        RJMP    ??CompareCurrentWithStoredCrc_4
//  230         }
//  231     }
??CompareCurrentWithStoredCrc_3:
        ADIW    R31:R30, 1
        RJMP    ??CompareCurrentWithStoredCrc_1
//  232 
//  233     // Все блоки принадлежат текущей базе данных.
//  234     return true;
??CompareCurrentWithStoredCrc_2:
        LDI     R16, 1
??CompareCurrentWithStoredCrc_4:
        MOVW    R27:R26, R23:R22
        RET
//  235 }
//  236 
//  237 //-----------------------------------------------------------------------------------------------------
//  238 // Вызывается только если база данных подтверждена пользователем.

        RSEG CODE:CODE:NOROOT(1)
//  239 void CDataStore::CrcOfBlocksCrcCreate(void)
??CrcOfBlocksCrcCreate:
//  240 {
        ST      -Y, R27
        ST      -Y, R26
        SBIW    R29:R28, 24
//  241     // Контрольная сумма вычисленная из массива контрольных сумм блоков, не включая служебный.
//  242     // Сохраняется при первой и последующих записях любых блоков через программатор.
//  243     // Ноль или её несовпадение свидетельствует о том, что база данных создана по умоланию,
//  244     // и не подтверждена пользователем. В этом случае прибор переходит в режим сигнализации об ошибке,
//  245     // ожидая квитирования или записи базы данных.
//  246     uint16_t auiBlocksCrc[MAX_BLOCKS_NUMBER - BLOCKS_CONTROL_DATA_BLOCK_NUMBER];
//  247 
//  248     // Получим Crc всех блоков, не включая служебный.
//  249     for (uint16_t i = 0;
        LDI     R30, 0
        LDI     R31, 0
//  250             i < (MAX_BLOCKS_NUMBER - BLOCKS_CONTROL_DATA_BLOCK_NUMBER);
??CrcOfBlocksCrcCreate_1:
        CPI     R30, 12
        LDI     R16, 0
        CPC     R31, R16
        BRCC    ??CrcOfBlocksCrcCreate_2
//  251             i++)
//  252     {
//  253         auiBlocksCrc[i] =
//  254             m_xBlocksControlData.axBlockPositionData[i + BLOCKS_CONTROL_DATA_BLOCK_NUMBER].uiCrc;
        MOVW    R17:R16, R31:R30
        LDI     R20, 8
        LDI     R21, 0
        CALL    ?S_EC_MUL_L02
        MOVW    R27:R26, R17:R16
        SUBI    R26, LOW((-(??m_xBlocksControlData + 18) & 0xFFFF))
        SBCI    R27, HIGH((-(??m_xBlocksControlData + 18) & 0xFFFF))
        LD      R18, X+
        LD      R19, X
        SBIW    R27:R26, 1
        MOVW    R27:R26, R29:R28
        MOVW    R17:R16, R31:R30
        LSL     R16
        ROL     R17
        ADD     R26, R16
        ADC     R27, R17
        ST      X+, R18
        ST      X, R19
        SBIW    R27:R26, 1
//  255     }
        ADIW    R31:R30, 1
        RJMP    ??CrcOfBlocksCrcCreate_1
//  256 
//  257     // Сохраним Crc всех блоков, не включая служебный.
//  258     m_xBlocksControlData.uiCrcOfBlocksCrc =
//  259         usCrc16(reinterpret_cast<uint8_t*>(auiBlocksCrc),
//  260                 ((MAX_BLOCKS_NUMBER - BLOCKS_CONTROL_DATA_BLOCK_NUMBER) * sizeof(uint16_t)));
??CrcOfBlocksCrcCreate_2:
        LDI     R18, 24
        LDI     R19, 0
        MOVW    R17:R16, R29:R28
        CALL    ??usCrc16
        LDI     R30, LOW(??m_xBlocksControlData)
        LDI     R31, (??m_xBlocksControlData) >> 8
        ST      Z, R16
        STD     Z+1, R17
//  261 
//  262 }
        ADIW    R29:R28, 24
        LD      R26, Y+
        LD      R27, Y+
        RET
//  263 
//  264 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  265 bool CDataStore::CrcOfBlocksCrcCheck(void)
??CrcOfBlocksCrcCheck:
//  266 {
        ST      -Y, R27
        ST      -Y, R26
        SBIW    R29:R28, 24
//  267     // Контрольная сумма вычисленная из массива контрольных сумм блоков, не включая служебный.
//  268     // Сохраняется при первой и последующих записях любых блоков через программатор.
//  269     // Ноль или её несовпадение свидетельствует о том, что база данных создана по умоланию,
//  270     // и не подтверждена пользователем. В этом случае прибор переходит в режим сигнализации об ошибке,
//  271     // ожидая квитирования или записи базы данных.
//  272     uint16_t auiBlocksCrc[MAX_BLOCKS_NUMBER - BLOCKS_CONTROL_DATA_BLOCK_NUMBER];
//  273 
//  274     // Получим Crc всех блоков, не включая служебный.
//  275     for (uint16_t i = 0;
        LDI     R30, 0
        LDI     R31, 0
//  276             i < (MAX_BLOCKS_NUMBER - BLOCKS_CONTROL_DATA_BLOCK_NUMBER);
??CrcOfBlocksCrcCheck_1:
        CPI     R30, 12
        LDI     R16, 0
        CPC     R31, R16
        BRCC    ??CrcOfBlocksCrcCheck_2
//  277             i++)
//  278     {
//  279         auiBlocksCrc[i] =
//  280             m_xBlocksControlData.axBlockPositionData[i + BLOCKS_CONTROL_DATA_BLOCK_NUMBER].uiCrc;
        MOVW    R17:R16, R31:R30
        LDI     R20, 8
        LDI     R21, 0
        CALL    ?S_EC_MUL_L02
        MOVW    R27:R26, R17:R16
        SUBI    R26, LOW((-(??m_xBlocksControlData + 18) & 0xFFFF))
        SBCI    R27, HIGH((-(??m_xBlocksControlData + 18) & 0xFFFF))
        LD      R18, X+
        LD      R19, X
        SBIW    R27:R26, 1
        MOVW    R27:R26, R29:R28
        MOVW    R17:R16, R31:R30
        LSL     R16
        ROL     R17
        ADD     R26, R16
        ADC     R27, R17
        ST      X+, R18
        ST      X, R19
        SBIW    R27:R26, 1
//  281     }
        ADIW    R31:R30, 1
        RJMP    ??CrcOfBlocksCrcCheck_1
//  282 
//  283     // Crc из Crc всех блоков совпадает с сохранённым в служебном блоке?
//  284     if (m_xBlocksControlData.uiCrcOfBlocksCrc ==
//  285             usCrc16(reinterpret_cast<uint8_t*>(auiBlocksCrc),
//  286                     ((MAX_BLOCKS_NUMBER - BLOCKS_CONTROL_DATA_BLOCK_NUMBER) * sizeof(uint16_t))))
??CrcOfBlocksCrcCheck_2:
        LDI     R18, 24
        LDI     R19, 0
        MOVW    R17:R16, R29:R28
        CALL    ??usCrc16
        LDI     R30, LOW(??m_xBlocksControlData)
        LDI     R31, (??m_xBlocksControlData) >> 8
        LD      R18, Z
        LDD     R19, Z+1
        CP      R18, R16
        CPC     R19, R17
        BRNE    ??CrcOfBlocksCrcCheck_3
//  287     {
//  288         return true;
        LDI     R16, 1
        RJMP    ??CrcOfBlocksCrcCheck_4
//  289     }
//  290     else
//  291     {
//  292         return false;
??CrcOfBlocksCrcCheck_3:
        LDI     R16, 0
??CrcOfBlocksCrcCheck_4:
        ADIW    R29:R28, 24
        LD      R26, Y+
        LD      R27, Y+
        RET
//  293     }
//  294 }

        RSEG CODE:CODE:NOROOT(1)
??Fsm:
        CALL    ??GetFsmState
        SUBI    R16, 0
        BREQ    ??Fsm_1
        DEC     R16
        BREQ    ??Fsm_2
        DEC     R16
        BREQ    ??Fsm_3
        DEC     R16
        BREQ    ??Fsm_4
        DEC     R16
        BRNE    $+2+2
        RJMP    ??Fsm_5
        DEC     R16
        BRNE    $+2+2
        RJMP    ??Fsm_6
        DEC     R16
        BRNE    $+2+2
        RJMP    ??Fsm_7
??Fsm_1:
        RET
??Fsm_2:
        CALL    ??GetTimerPointer
        LDI     R18, 200
        LDI     R19, 0
        CALL    ??Set
        LDI     R16, 2
        CALL    ??SetFsmState
        RET
??Fsm_3:
        CALL    ??IsReadyToWrite
        TST     R16
        BREQ    ??Fsm_8
        CALL    ??GetTimerPointer
        LDI     R18, 16
        LDI     R19, 39
        CALL    ??Set
        CALL    ??StartWrite
        LDI     R16, 3
        CALL    ??SetFsmState
        RET
??Fsm_8:
        CALL    ??GetTimerPointer
        CALL    ??IsOverflow
        TST     R16
        BREQ    ??Fsm_9
        LDI     R16, 4
        CALL    ??SetFsmEvent
        LDI     R16, 0
        CALL    ??SetFsmState
??Fsm_9:
        RET
??Fsm_4:
        CALL    ??GetBufferIsWrited
        TST     R16
        BREQ    ??Fsm_10
        LDI     R16, 4
        CALL    ??SetFsmState
        RET
??Fsm_10:
        CALL    ??GetTimerPointer
        CALL    ??IsOverflow
        TST     R16
        BREQ    ??Fsm_11
        LDI     R16, 4
        CALL    ??SetFsmEvent
        LDI     R16, 0
        CALL    ??SetFsmState
??Fsm_11:
        RET
??Fsm_5:
        LDI     R20, 0
        LDI     R18, 108
        LDI     R19, 0
        LDI     R16, LOW(??m_xBlocksControlData)
        LDI     R17, (??m_xBlocksControlData) >> 8
        RCALL   ??Write
        OR      R16, R17
        BREQ    ??Fsm_12
        CALL    ??GetTimerPointer
        LDI     R18, 200
        LDI     R19, 0
        CALL    ??Set
        LDI     R16, 5
        CALL    ??SetFsmState
        RET
??Fsm_12:
        LDI     R16, 4
        CALL    ??SetFsmEvent
        LDI     R16, 0
        CALL    ??SetFsmState
        RET
??Fsm_6:
        CALL    ??IsReadyToWrite
        TST     R16
        BREQ    ??Fsm_13
        CALL    ??GetTimerPointer
        LDI     R18, 16
        LDI     R19, 39
        CALL    ??Set
        CALL    ??StartWrite
        LDI     R16, 6
        CALL    ??SetFsmState
        RET
??Fsm_13:
        CALL    ??GetTimerPointer
        CALL    ??IsOverflow
        TST     R16
        BREQ    ??Fsm_14
        LDI     R16, 4
        CALL    ??SetFsmEvent
        LDI     R16, 0
        CALL    ??SetFsmState
        RET
??Fsm_7:
        CALL    ??GetBufferIsWrited
        TST     R16
        BREQ    ??Fsm_15
        LDI     R16, 3
        CALL    ??SetFsmEvent
        LDI     R16, 0
        CALL    ??SetFsmState
        RET
??Fsm_15:
        CALL    ??GetTimerPointer
        CALL    ??IsOverflow
        TST     R16
        BREQ    ??Fsm_14
        LDI     R16, 4
        CALL    ??SetFsmEvent
        LDI     R16, 0
        CALL    ??SetFsmState
??Fsm_14:
        RET
//  295 
//  296 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  297 uint8_t CDataStore::Check(void)
??Check:
//  298 {
        CALL    ?PROLOGUE4_L09
//  299     CDataStore::Init();
        RCALL   ??Init
//  300 
//  301     // Служебный блок повреждён?
//  302     if (!(ReadBlock(reinterpret_cast<uint8_t*>(&m_xBlocksControlData), BLOCKS_CONTROL_DATA)))
        LDI     R18, 0
        LDI     R16, LOW(??m_xBlocksControlData)
        LDI     R17, (??m_xBlocksControlData) >> 8
        RCALL   ??ReadBlock
        OR      R16, R17
        BRNE    ??Check_1
//  303     {
//  304         return 0;
        LDI     R16, 0
        RJMP    ??Check_2
//  305     }
//  306 
//  307     enum
//  308     {
//  309         IDDLE = 0,
//  310         BLOCK_CHECK_START,
//  311         BLOCK_WRITE_START,
//  312         BLOCK_WRITE_END_WAITING,
//  313         NEXT_BLOCK,
//  314         BLOCK_ERROR,
//  315         ALL_BLOCKS_CHECKED,
//  316     };
//  317 
//  318     uint8_t uiBlockCounter = 0;
??Check_1:
        LDI     R27, 0
//  319     uint8_t uiFsmState = BLOCK_CHECK_START;
        LDI     R26, 1
//  320     uint16_t uiLength;
//  321 
//  322     CHammingCodes::SetErrorCode(CHammingCodes::NONE_ERROR);
        LDI     R16, 0
        CALL    ??SetErrorCode_1
//  323 
//  324     while (1)
//  325     {
//  326         switch (uiFsmState)
??Check_3:
        MOV     R16, R26
        SUBI    R16, 1
        BREQ    ??Check_4
        DEC     R16
        BREQ    ??Check_5
        DEC     R16
        BREQ    ??Check_6
        DEC     R16
        BREQ    ??Check_7
        DEC     R16
        BREQ    ??Check_8
        DEC     R16
        BREQ    ??Check_9
        RJMP    ??Check_10
//  327         {
//  328         case BLOCK_CHECK_START:
//  329             // Проверены не все блоки?
//  330             if (uiBlockCounter < MAX_BLOCKS_NUMBER)
??Check_4:
        CPI     R27, 13
        BRCC    ??Check_11
//  331             {
//  332                 uiLength = ReadBlock(m_puiIntermediateBuff, uiBlockCounter);
        MOV     R18, R27
        LDI     R30, LOW(??m_puiIntermediateBuff)
        LDI     R31, (??m_puiIntermediateBuff) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        RCALL   ??ReadBlock
        MOVW    R25:R24, R17:R16
//  333                 // Блок не повреждён?
//  334                 if (uiLength)
        MOV     R16, R24
        OR      R16, R25
        BREQ    ??Check_12
//  335                 {
//  336                     // Блок восстановлен после обнаружения ошибки?
//  337                     if (CHammingCodes::GetErrorCode() != CHammingCodes::NONE_ERROR)
        CALL    ??GetErrorCode
        TST     R16
        BREQ    ??Check_13
//  338                     {
//  339                         // Обновим восстановленный блок в хранилище.
//  340                         uiFsmState = BLOCK_WRITE_START;
        LDI     R26, 2
        RJMP    ??Check_10
//  341                     }
//  342                     else
//  343                     {
//  344                         uiFsmState = NEXT_BLOCK;
??Check_13:
        LDI     R26, 4
        RJMP    ??Check_10
//  345                     }
//  346                 }
//  347                 else
//  348                 {
//  349                     uiFsmState = BLOCK_ERROR;
??Check_12:
        LDI     R26, 5
        RJMP    ??Check_10
//  350                 }
//  351             }
//  352             else
//  353             {
//  354                 uiFsmState = ALL_BLOCKS_CHECKED;
??Check_11:
        LDI     R26, 6
//  355             }
//  356             break;
        RJMP    ??Check_10
//  357 
//  358         case BLOCK_WRITE_START:
//  359             // Поместим данные в хранилище.
//  360             // Блок БД принят к записи?
//  361             if (WriteBlock(m_puiIntermediateBuff, uiLength, uiBlockCounter))
??Check_5:
        MOV     R20, R27
        MOVW    R19:R18, R25:R24
        LDI     R30, LOW(??m_puiIntermediateBuff)
        LDI     R31, (??m_puiIntermediateBuff) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        RCALL   ??WriteBlock
        TST     R16
        BREQ    ??Check_14
//  362             {
//  363                 uiFsmState = BLOCK_WRITE_END_WAITING;
        LDI     R26, 3
        RJMP    ??Check_10
//  364             }
//  365             // При записи блока БД произошла ошибка?
//  366             else if (CDataStore::GetFsmEvent() == CDataStore::WRITE_ERROR_FSM_EVENT)
??Check_14:
        CALL    ??GetFsmEvent
        CPI     R16, 4
        BRNE    ??Check_10
//  367             {
//  368                 uiFsmState = BLOCK_ERROR;
        LDI     R26, 5
//  369             }
//  370             break;
        RJMP    ??Check_10
//  371 
//  372         case BLOCK_WRITE_END_WAITING:
//  373             // Блок записан успешно?
//  374             if (CDataStore::GetFsmEvent() == CDataStore::WRITE_OK_FSM_EVENT)
??Check_6:
        CALL    ??GetFsmEvent
        CPI     R16, 3
        BRNE    ??Check_15
//  375             {
//  376                 uiFsmState = NEXT_BLOCK;
        LDI     R26, 4
        RJMP    ??Check_10
//  377             }
//  378             // При записи блока БД произошла ошибка?
//  379             else if (CDataStore::GetFsmEvent() == CDataStore::WRITE_ERROR_FSM_EVENT)
??Check_15:
        CALL    ??GetFsmEvent
        CPI     R16, 4
        BRNE    ??Check_10
//  380             {
//  381                 uiFsmState = BLOCK_ERROR;
        LDI     R26, 5
//  382             }
//  383             break;
        RJMP    ??Check_10
//  384 
//  385         case NEXT_BLOCK:
//  386             uiBlockCounter++;
??Check_7:
        INC     R27
//  387             uiFsmState = BLOCK_CHECK_START;
        LDI     R26, 1
//  388             break;
        RJMP    ??Check_10
//  389 
//  390         case ALL_BLOCKS_CHECKED:
//  391             // данные не повреждены.
//  392             return 1;
??Check_9:
        LDI     R16, 1
        RJMP    ??Check_2
//  393             break;
//  394 
//  395         case BLOCK_ERROR:
//  396             return 0;
??Check_8:
        LDI     R16, 0
        RJMP    ??Check_2
//  397             break;
//  398 
//  399         default:
//  400             break;
//  401         }
//  402 
//  403         CDataStore::Fsm();
??Check_10:
        RCALL   ??Fsm
//  404 
//  405         delay_ms(10);
        LDI     R16, 10
        LDI     R17, 0
        CALL    ??delay_ms
//  406 
//  407         CPlatform::WatchdogReset();
        CALL    ??WatchdogReset
        RJMP    ??Check_3
//  408     }
??Check_2:
        LDI     R30, 4
        JMP     ?EPILOGUE_B4_L09
//  409 }
//  410 
//  411 //-----------------------------------------------------------------------------------------------------
//  412 void CDataStore::Fsm(void)
//  413 {
//  414     switch (GetFsmState())
//  415     {
//  416     case IDDLE:
//  417         break;
//  418 
//  419     case START_WRITE:
//  420         // Установим время ожидания готовности к записи.
//  421         GetTimerPointer() -> Set(READY_TO_WRITE_WAITING_TIMEOUT);
//  422         SetFsmState(READY_TO_WRITE_WAITING);
//  423         break;
//  424 
//  425     case READY_TO_WRITE_WAITING:
//  426         if (CEeprom::IsReadyToWrite())
//  427         {
//  428             // Установим время ожидания окончания записи записи.
//  429             GetTimerPointer() -> Set(WRITE_END_WAITING_TIMEOUT);
//  430             CEeprom::StartWrite();
//  431             SetFsmState(WRITE_END_WAITING);
//  432         }
//  433         // Время ожидания готовности к записи закончилось?
//  434         else if (GetTimerPointer() -> IsOverflow())
//  435         {
//  436             SetFsmEvent(WRITE_ERROR_FSM_EVENT);
//  437             SetFsmState(IDDLE);
//  438         }
//  439         break;
//  440 
//  441     case WRITE_END_WAITING:
//  442         if (CEeprom::GetBufferIsWrited())
//  443         {
//  444             SetFsmState(START_WRITE_BLOCKS_CONTROL_DATA);
//  445         }
//  446         // Время ожидания окончания записи закончилось?
//  447         else if (GetTimerPointer() -> IsOverflow())
//  448         {
//  449             SetFsmEvent(WRITE_ERROR_FSM_EVENT);
//  450             SetFsmState(IDDLE);
//  451         }
//  452         break;
//  453 
//  454 
//  455     // Запись служеьного блока.
//  456     case START_WRITE_BLOCKS_CONTROL_DATA:
//  457         // Данные обновлены.
//  458         // Сохраним изменённый служебный контекст.
//  459         if (Write(reinterpret_cast<uint8_t*>(&m_xBlocksControlData),
//  460                   sizeof(m_xBlocksControlData),
//  461                   BLOCKS_CONTROL_DATA))
//  462         {
//  463             // Установим время ожидания готовности к записи.
//  464             GetTimerPointer() -> Set(READY_TO_WRITE_WAITING_TIMEOUT);
//  465             SetFsmState(READY_TO_WRITE_WAITING_BLOCKS_CONTROL_DATA);
//  466         }
//  467         else
//  468         {
//  469             SetFsmEvent(WRITE_ERROR_FSM_EVENT);
//  470             SetFsmState(IDDLE);
//  471         }
//  472         break;
//  473 
//  474     case READY_TO_WRITE_WAITING_BLOCKS_CONTROL_DATA:
//  475         if (CEeprom::IsReadyToWrite())
//  476         {
//  477             // Установим время ожидания окончания записи.
//  478             GetTimerPointer() -> Set(WRITE_END_WAITING_TIMEOUT);
//  479             CEeprom::StartWrite();
//  480             SetFsmState(WRITE_END_WAITING_BLOCKS_CONTROL_DATA);
//  481         }
//  482         // Время ожидания готовности к записи закончилось?
//  483         else if (GetTimerPointer() -> IsOverflow())
//  484         {
//  485             SetFsmEvent(WRITE_ERROR_FSM_EVENT);
//  486             SetFsmState(IDDLE);
//  487         }
//  488         break;
//  489 
//  490     case WRITE_END_WAITING_BLOCKS_CONTROL_DATA:
//  491         if (CEeprom::GetBufferIsWrited())
//  492         {
//  493             SetFsmEvent(WRITE_OK_FSM_EVENT);
//  494             SetFsmState(IDDLE);
//  495         }
//  496         // Время ожидания окончания записи закончилось?
//  497         else if (GetTimerPointer() -> IsOverflow())
//  498         {
//  499             SetFsmEvent(WRITE_ERROR_FSM_EVENT);
//  500             SetFsmState(IDDLE);
//  501         }
//  502         break;
//  503 
//  504     default:
//  505         break;
//  506     }
//  507 }
//  508 
//  509 //-----------------------------------------------------------------------------------------------------
//  510 
//  511 
//  512 
//  513 
//  514 
//  515 
//  516 
//  517 
//  518 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  519 uint16_t CDataStore::ReadBlockFlash(uint8_t *puiDestination, uint8_t uiBlock)
??ReadBlockFlash:
//  520 {
        CALL    ?PROLOGUE3_L09
        MOVW    R25:R24, R17:R16
        MOV     R26, R18
//  521     return CFlash::ReadBlock(puiDestination, uiBlock);
        MOV     R18, R26
        MOVW    R17:R16, R25:R24
        CALL    ??ReadBlock_6
        LDI     R30, 3
        JMP     ?EPILOGUE_B3_L09
//  522 }

        RSEG CODE:CODE:NOROOT(1)
// __version_3 void CEeprom::ReadyInterruptEnable()
??ReadyInterruptEnable:
        SBI     0x1C, 0x03
        RET
        REQUIRE _A_EECR

        RSEG CODE:CODE:NOROOT(1)
// __version_3 bool CEeprom::IsReadyToWrite()
??IsReadyToWrite:
        SBIS    0x1C, 0x01
        RJMP    ??IsReadyToWrite_1
        LDI     R16, 0
        RET
??IsReadyToWrite_1:
        LDI     R16, 1
        RET
        REQUIRE _A_EECR

        RSEG CODE:CODE:NOROOT(1)
// __version_3 void CEeprom::SetBufferIsWrited(bool)
??SetBufferIsWrited:
        STS     ??m_bBufferIsWrited, R16
        RET

        RSEG CODE:CODE:NOROOT(1)
// __version_3 bool CEeprom::GetBufferIsWrited()
??GetBufferIsWrited:
        LDS     R16, ??m_bBufferIsWrited
        RET

        RSEG CODE:CODE:NOROOT(1)
// __version_3 void CEeprom::StartWrite()
??StartWrite:
        LDI     R16, 0
        CALL    ??SetBufferIsWrited
        CALL    ??ReadyInterruptEnable
        RET

        RSEG CODE:CODE:NOROOT(1)
// __version_3 void CPlatform::WatchdogReset()
??WatchdogReset:
        WDR
        RET

        RSEG CODE:CODE:NOROOT(1)
// __version_3 uint8_t CDataStore::GetFsmEvent()
??GetFsmEvent:
        LDS     R16, ??m_uiFsmEvent
        RET

        RSEG CODE:CODE:NOROOT(1)
// __version_3 CTimer *CDataStore::GetTimerPointer()
??GetTimerPointer:
        LDI     R16, LOW(??m_xTimer)
        LDI     R17, (??m_xTimer) >> 8
        RET

        RSEG CODE:CODE:NOROOT(1)
// __version_3 void CDataStore::SetFsmState(uint8_t)
??SetFsmState:
        STS     ??m_uiFsmState, R16
        RET

        RSEG CODE:CODE:NOROOT(1)
// __version_3 uint8_t CDataStore::GetFsmState()
??GetFsmState:
        LDS     R16, ??m_uiFsmState
        RET

        RSEG CODE:CODE:NOROOT(1)
// __version_3 void CDataStore::SetFsmEvent(uint8_t)
??SetFsmEvent:
        STS     ??m_uiFsmEvent, R16
        RET

        RSEG CODE:CODE:NOROOT(1)
// __version_3 void CPss21::SetErrorCode(uint8_t)
??SetErrorCode:
        STS     ??m_uiErrorCode, R16
        RET

        RSEG CODE:CODE:NOROOT(1)
// __version_3 void CHammingCodes::SetErrorCode(uint8_t)
??SetErrorCode_1:
        STS     ??m_uiErrorCode_1, R16
        RET

        RSEG CODE:CODE:NOROOT(1)
// __version_3 uint8_t CHammingCodes::GetErrorCode()
??GetErrorCode:
        LDS     R16, ??m_uiErrorCode_1
        RET

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_Z>`:
        DC16    SFE(NEAR_Z) - SFB(NEAR_Z)
        DC16    SFB(NEAR_Z)
        DP      0
        REQUIRE ?need_segment_init

        RSEG NEAR_ID:CODE:ROOT(0)
`?<Initializer for >`:
        DC16 ?_1, ??m_xTimer, `?<Unnamed 0>`/2

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_I>`:
        DC16    SFE(NEAR_I) - SFB(NEAR_I)
        DC16    SFB(NEAR_I)
        DP      SFB(NEAR_ID)
        REQUIRE ?need_segment_init

        RSEG DIFUNCT:CODE:ROOT(0)
        REQUIRE ?call_ctors
        DW      ??__sti__routine/2

        RSEG NEAR_F:CODE:ROOT(0)
        DC8 0, 0, 0, 0

        RSEG NEAR_F:CODE:ROOT(0)
        DC8 0, 0, 0, 0, 0, 0, 0, 0

        RSEG NEAR_F:CODE:ROOT(0)
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        END
// 
//   105 bytes in segment ABSOLUTE
// 1 658 bytes in segment CODE
//     2 bytes in segment DIFUNCT
//    14 bytes in segment INITTAB
//    22 bytes in segment NEAR_F
//     6 bytes in segment NEAR_I
//     6 bytes in segment NEAR_ID
//   146 bytes in segment NEAR_Z
// 
// 1 596 bytes of CODE memory (+ 106 bytes shared)
//   152 bytes of DATA memory (+ 105 bytes shared)
//
//Errors: none
//Warnings: 7

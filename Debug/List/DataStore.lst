###############################################################################
#
# IAR C/C++ Compiler V7.10.6.1378 for Atmel AVR           11/Sep/2024  06:58:03
# Copyright 1996-2018 IAR Systems AB.
#
#    Source file  =  
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\src\DataStore.cpp
#    Command line =  
#        -f C:\Users\Admin\AppData\Local\Temp\EWA788.tmp
#        (--string_literals_in_flash
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\src\DataStore.cpp
#        --cpu=m128a -ms -o
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\Obj -lC
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\List -lB
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\List -y
#        --initializers_in_flash --root_variables --no_cse --no_inline
#        --no_code_motion --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e -I
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Modbus\ -I
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\include\
#        --eeprom_size 4096 --dlib --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -On
#        --eec++)
#    Locale       =  Russian_RUS.1251
#    List file    =  
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\List\DataStore.lst
#    Object file  =  
#        D:\Projects\CurrentProjects\CautoProjects\PSS48Color\Debug\Obj\DataStore.r90
#
###############################################################################

D:\Projects\CurrentProjects\CautoProjects\PSS48Color\src\DataStore.cpp
      1          
      2          //-----------------------------------------------------------------------------------------------------
      3          //  Source      : FileName.cpp
      4          //  Created     : 01.06.2022
      5          //  Author      : Alexandr Volvenkin
      6          //  email       : aav-36@mail.ru
      7          //  GitHub      : https://github.com/AlexandrVolvenkin
      8          //-----------------------------------------------------------------------------------------------------
      9          #include "DataStore.h"

   \                                 In  segment ABSOLUTE, at 0x9d, root
   \   union <unnamed> volatile __io _A_UCSR1C
   \                     _A_UCSR1C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x9c, root
   \   union <unnamed> volatile __io _A_UDR1
   \                     _A_UDR1:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x9b, root
   \   union <unnamed> volatile __io _A_UCSR1A
   \                     _A_UCSR1A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x9a, root
   \   union <unnamed> volatile __io _A_UCSR1B
   \                     _A_UCSR1B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x99, root
   \   union <unnamed> volatile __io _A_UBRR1L
   \                     _A_UBRR1L:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x98, root
   \   union <unnamed> volatile __io _A_UBRR1H
   \                     _A_UBRR1H:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x95, root
   \   union <unnamed> volatile __io _A_UCSR0C
   \                     _A_UCSR0C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x90, root
   \   union <unnamed> volatile __io _A_UBRR0H
   \                     _A_UBRR0H:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x8c, root
   \   union <unnamed> volatile __io _A_TCCR3C
   \                     _A_TCCR3C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x8b, root
   \   union <unnamed> volatile __io _A_TCCR3A
   \                     _A_TCCR3A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x8a, root
   \   union <unnamed> volatile __io _A_TCCR3B
   \                     _A_TCCR3B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x88, root
   \   union <unnamed> volatile __io _A_TCNT3
   \                     _A_TCNT3:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x86, root
   \   union <unnamed> volatile __io _A_OCR3A
   \                     _A_OCR3A:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x84, root
   \   union <unnamed> volatile __io _A_OCR3B
   \                     _A_OCR3B:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x82, root
   \   union <unnamed> volatile __io _A_OCR3C
   \                     _A_OCR3C:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x80, root
   \   union <unnamed> volatile __io _A_ICR3
   \                     _A_ICR3:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x7d, root
   \   union <unnamed> volatile __io _A_ETIMSK
   \                     _A_ETIMSK:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x7c, root
   \   union <unnamed> volatile __io _A_ETIFR
   \                     _A_ETIFR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x7a, root
   \   union <unnamed> volatile __io _A_TCCR1C
   \                     _A_TCCR1C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x78, root
   \   union <unnamed> volatile __io _A_OCR1C
   \                     _A_OCR1C:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x74, root
   \   union <unnamed> volatile __io _A_TWCR
   \                     _A_TWCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x73, root
   \   union <unnamed> volatile __io _A_TWDR
   \                     _A_TWDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x72, root
   \   union <unnamed> volatile __io _A_TWAR
   \                     _A_TWAR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x71, root
   \   union <unnamed> volatile __io _A_TWSR
   \                     _A_TWSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x70, root
   \   union <unnamed> volatile __io _A_TWBR
   \                     _A_TWBR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6f, root
   \   union <unnamed> volatile __io _A_OSCCAL
   \                     _A_OSCCAL:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6d, root
   \   union <unnamed> volatile __io _A_XMCRA
   \                     _A_XMCRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6c, root
   \   union <unnamed> volatile __io _A_XMCRB
   \                     _A_XMCRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6a, root
   \   union <unnamed> volatile __io _A_EICRA
   \                     _A_EICRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x68, root
   \   union <unnamed> volatile __io _A_SPMCSR
   \                     _A_SPMCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x65, root
   \   union <unnamed> volatile __io _A_PORTG
   \                     _A_PORTG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x64, root
   \   union <unnamed> volatile __io _A_DDRG
   \                     _A_DDRG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x63, root
   \   union <unnamed> volatile __io _A_PING
   \                     _A_PING:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x62, root
   \   union <unnamed> volatile __io _A_PORTF
   \                     _A_PORTF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x61, root
   \   union <unnamed> volatile __io _A_DDRF
   \                     _A_DDRF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x5f, root
   \   union <unnamed> volatile __io _A_SREG
   \                     _A_SREG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x5d, root
   \   union <unnamed> volatile __io _A_SP
   \                     _A_SP:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x5c, root
   \   union <unnamed> volatile __io _A_XDIV
   \                     _A_XDIV:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x5b, root
   \   union <unnamed> volatile __io _A_RAMPZ
   \                     _A_RAMPZ:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x5a, root
   \   union <unnamed> volatile __io _A_EICRB
   \                     _A_EICRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x59, root
   \   union <unnamed> volatile __io _A_EIMSK
   \                     _A_EIMSK:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x58, root
   \   union <unnamed> volatile __io _A_EIFR
   \                     _A_EIFR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x57, root
   \   union <unnamed> volatile __io _A_TIMSK
   \                     _A_TIMSK:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x56, root
   \   union <unnamed> volatile __io _A_TIFR
   \                     _A_TIFR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x55, root
   \   union <unnamed> volatile __io _A_MCUCR
   \                     _A_MCUCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x54, root
   \   union <unnamed> volatile __io _A_MCUCSR
   \                     _A_MCUCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x53, root
   \   union <unnamed> volatile __io _A_TCCR0
   \                     _A_TCCR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x52, root
   \   union <unnamed> volatile __io _A_TCNT0
   \                     _A_TCNT0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x51, root
   \   union <unnamed> volatile __io _A_OCR0
   \                     _A_OCR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x50, root
   \   union <unnamed> volatile __io _A_ASSR
   \                     _A_ASSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4f, root
   \   union <unnamed> volatile __io _A_TCCR1A
   \                     _A_TCCR1A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4e, root
   \   union <unnamed> volatile __io _A_TCCR1B
   \                     _A_TCCR1B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4c, root
   \   union <unnamed> volatile __io _A_TCNT1
   \                     _A_TCNT1:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x4a, root
   \   union <unnamed> volatile __io _A_OCR1A
   \                     _A_OCR1A:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x48, root
   \   union <unnamed> volatile __io _A_OCR1B
   \                     _A_OCR1B:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x46, root
   \   union <unnamed> volatile __io _A_ICR1
   \                     _A_ICR1:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x45, root
   \   union <unnamed> volatile __io _A_TCCR2
   \                     _A_TCCR2:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x44, root
   \   union <unnamed> volatile __io _A_TCNT2
   \                     _A_TCNT2:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x43, root
   \   union <unnamed> volatile __io _A_OCR2
   \                     _A_OCR2:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x42, root
   \   union <unnamed> volatile __io _A_OCDR
   \                     _A_OCDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x41, root
   \   union <unnamed> volatile __io _A_WDTCR
   \                     _A_WDTCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x40, root
   \   union <unnamed> volatile __io _A_SFIOR
   \                     _A_SFIOR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3e, root
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x3d, root
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3c, root
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3b, root
   \   union <unnamed> volatile __io _A_PORTA
   \                     _A_PORTA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3a, root
   \   union <unnamed> volatile __io _A_DDRA
   \                     _A_DDRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x39, root
   \   union <unnamed> volatile __io _A_PINA
   \                     _A_PINA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x38, root
   \   union <unnamed> volatile __io _A_PORTB
   \                     _A_PORTB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x37, root
   \   union <unnamed> volatile __io _A_DDRB
   \                     _A_DDRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x36, root
   \   union <unnamed> volatile __io _A_PINB
   \                     _A_PINB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x35, root
   \   union <unnamed> volatile __io _A_PORTC
   \                     _A_PORTC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x34, root
   \   union <unnamed> volatile __io _A_DDRC
   \                     _A_DDRC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x33, root
   \   union <unnamed> volatile __io _A_PINC
   \                     _A_PINC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x32, root
   \   union <unnamed> volatile __io _A_PORTD
   \                     _A_PORTD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x31, root
   \   union <unnamed> volatile __io _A_DDRD
   \                     _A_DDRD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x30, root
   \   union <unnamed> volatile __io _A_PIND
   \                     _A_PIND:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2f, root
   \   union <unnamed> volatile __io _A_SPDR
   \                     _A_SPDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e, root
   \   union <unnamed> volatile __io _A_SPSR
   \                     _A_SPSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2d, root
   \   union <unnamed> volatile __io _A_SPCR
   \                     _A_SPCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2c, root
   \   union <unnamed> volatile __io _A_UDR0
   \                     _A_UDR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2b, root
   \   union <unnamed> volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2a, root
   \   union <unnamed> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x29, root
   \   union <unnamed> volatile __io _A_UBRR0L
   \                     _A_UBRR0L:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x28, root
   \   union <unnamed> volatile __io _A_ACSR
   \                     _A_ACSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x27, root
   \   union <unnamed> volatile __io _A_ADMUX
   \                     _A_ADMUX:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x26, root
   \   union <unnamed> volatile __io _A_ADCSRA
   \                     _A_ADCSRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x24, root
   \   union <unnamed> volatile __io _A_ADC
   \                     _A_ADC:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x23, root
   \   union <unnamed> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x22, root
   \   union <unnamed> volatile __io _A_DDRE
   \                     _A_DDRE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x21, root
   \   union <unnamed> volatile __io _A_PINE
   \                     _A_PINE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x20, root
   \   union <unnamed> volatile __io _A_PINF
   \                     _A_PINF:
   \   00000000                      DS8 1

   \                                 In  segment CODE, align 2, keep-with-next
   \   __version_3 void CEeprom::ReadyInterruptEnable()
   \                     ??ReadyInterruptEnable:
   \   00000000   9AE3               SBI     0x1C, 0x03
   \   00000002   9508               RET
   \   00000004                      REQUIRE _A_EECR

   \                                 In  segment CODE, align 2, keep-with-next
   \   __version_3 bool CEeprom::IsReadyToWrite()
   \                     ??IsReadyToWrite:
   \   00000000   9BE1               SBIS    0x1C, 0x01
   \   00000002   C002               RJMP    ??IsReadyToWrite_1
   \   00000004   E000               LDI     R16, 0
   \   00000006   9508               RET
   \                     ??IsReadyToWrite_1:
   \   00000008   E001               LDI     R16, 1
   \   0000000A   9508               RET
   \   0000000C                      REQUIRE _A_EECR

   \                                 In  segment CODE, align 2, keep-with-next
   \   __version_3 void CEeprom::SetBufferIsWrited(bool)
   \                     ??SetBufferIsWrited:
   \   00000000   9300....           STS     ??m_bBufferIsWrited, R16
   \   00000004   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \   __version_3 bool CEeprom::GetBufferIsWrited()
   \                     ??GetBufferIsWrited:
   \   00000000   9100....           LDS     R16, ??m_bBufferIsWrited
   \   00000004   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \   __version_3 void CEeprom::StartWrite()
   \                     ??StartWrite:
   \   00000000   E000               LDI     R16, 0
   \   00000002   ........           CALL    ??SetBufferIsWrited
   \   00000006   ........           CALL    ??ReadyInterruptEnable
   \   0000000A   9508               RET

      static __flash TDataBase CFlash::xMainDataBase;
                               ^
"D:\Projects\CurrentProjects\CautoProjects\PSS48Color\include\Platform.h",368  Warning[Pe427]: 
          qualified name is not allowed in member declaration

      static __flash TDataBaseBlockPositionData CFlash::axDataBaseBlocksPositionData[];
                                                ^
"D:\Projects\CurrentProjects\CautoProjects\PSS48Color\include\Platform.h",369  Warning[Pe427]: 
          qualified name is not allowed in member declaration

   \                                 In  segment CODE, align 2, keep-with-next
   \   __version_3 void CPlatform::WatchdogReset()
   \                     ??WatchdogReset:
   \   00000000   95A8               WDR
   \   00000002   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \   __version_3 uint8_t CDataStore::GetFsmEvent()
   \                     ??GetFsmEvent:
   \   00000000   9100....           LDS     R16, ??m_uiFsmEvent
   \   00000004   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \   __version_3 CTimer *CDataStore::GetTimerPointer()
   \                     ??GetTimerPointer:
   \   00000000   ....               LDI     R16, LOW(??m_xTimer)
   \   00000002   ....               LDI     R17, (??m_xTimer) >> 8
   \   00000004   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \   __version_3 void CDataStore::SetFsmState(uint8_t)
   \                     ??SetFsmState:
   \   00000000   9300....           STS     ??m_uiFsmState, R16
   \   00000004   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \   __version_3 uint8_t CDataStore::GetFsmState()
   \                     ??GetFsmState:
   \   00000000   9100....           LDS     R16, ??m_uiFsmState
   \   00000004   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \   __version_3 void CDataStore::SetFsmEvent(uint8_t)
   \                     ??SetFsmEvent:
   \   00000000   9300....           STS     ??m_uiFsmEvent, R16
   \   00000004   9508               RET
     10          #include "Platform.h"
     11          #include "Pss21.h"

      virtual bool IsSolved(void) {};
                                   ^
"D:\Projects\CurrentProjects\CautoProjects\PSS48Color\include\Task.h",20  Warning[Pe940]: 
          missing return statement at end of non-void function
          "CTaskInterface::IsSolved"

      virtual bool IsSourceStateActive(void) {};
                                              ^
"D:\Projects\CurrentProjects\CautoProjects\PSS48Color\include\Task.h",23  Warning[Pe940]: 
          missing return statement at end of non-void function
          "CTaskInterface::IsSourceStateActive"

      bool IsSolved(void) {};
                           ^
"D:\Projects\CurrentProjects\CautoProjects\PSS48Color\include\Task.h",58  Warning[Pe940]: 
          missing return statement at end of non-void function
          "CIsRegularButtonPressedInterface::IsSolved"

      virtual bool IsSourceStateActive(void) {};
                                              ^
"D:\Projects\CurrentProjects\CautoProjects\PSS48Color\include\Task.h",61  Warning[Pe940]: 
          missing return statement at end of non-void function
          "CIsRegularButtonPressedInterface::IsSourceStateActive"

      virtual uint16_t KEY_PRESSED_TIME(void) {};
                                               ^
"D:\Projects\CurrentProjects\CautoProjects\PSS48Color\include\Task.h",63  Warning[Pe940]: 
          missing return statement at end of non-void function
          "CIsRegularButtonPressedInterface::KEY_PRESSED_TIME"

   \                                 In  segment CODE, align 2, keep-with-next
   \   __version_3 void CPss21::SetErrorCode(uint8_t)
   \                     ??SetErrorCode:
   \   00000000   9300....           STS     ??m_uiErrorCode, R16
   \   00000004   9508               RET
     12          #include "Crc.h"
     13          #include "HammingCodes.h"

   \                                 In  segment CODE, align 2, keep-with-next
   \   __version_3 void CHammingCodes::SetErrorCode(uint8_t)
   \                     ??SetErrorCode_1:
   \   00000000   9300....           STS     ??m_uiErrorCode_1, R16
   \   00000004   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \   __version_3 uint8_t CHammingCodes::GetErrorCode()
   \                     ??GetErrorCode:
   \   00000000   9100....           LDS     R16, ??m_uiErrorCode_1
   \   00000004   9508               RET
     14          
     15          
     16          // Служебные данные системы хранения.

   \                                 In  segment NEAR_Z, align 1, keep-with-next, root
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     17          CDataStore::TBlocksControlData CDataStore::m_xBlocksControlData;
   \                     ??m_xBlocksControlData:
   \   00000000                      DS8 108
     18          // Массив контрольных сумм блоков.

   \                                 In  segment NEAR_Z, align 1, keep-with-next, root
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     19          uint16_t CDataStore::m_auiBlocksCurrentCrc[MAX_BLOCKS_NUMBER];
   \                     ??m_auiBlocksCurrentCrc:
   \   00000000                      DS8 26

   \                                 In  segment NEAR_Z, align 1, keep-with-next, root
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     20          uint8_t* CDataStore::m_puiIntermediateBuff;
   \                     ??m_puiIntermediateBuff:
   \   00000000                      DS8 2

   \                                 In  segment CODE, align 2, keep-with-next
   \   static __intrinsic __version_3 void __sti__routine()
   \                     ??__sti__routine:
     21          CTimer CDataStore::m_xTimer;
   \   00000000   ....               LDI     R16, LOW(??m_xTimer)
   \   00000002   ....               LDI     R17, (??m_xTimer) >> 8
   \   00000004   ........           CALL    ??CTimer
   \   00000008   ....               LDI     R16, LOW(?_0)
   \   0000000A   ....               LDI     R17, (?_0) >> 8
   \   0000000C   ........           CALL    __record_needed_destruction
   \   00000010   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     `?<Unnamed 0>`:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   01C8               MOVW    R25:R24, R17:R16
   \   00000006   E022               LDI     R18, 2
   \   00000008   E030               LDI     R19, 0
   \   0000000A   018C               MOVW    R17:R16, R25:R24
   \   0000000C   ........           CALL    `?~CTimer`
   \   00000010   9189               LD      R24, Y+
   \   00000012   9199               LD      R25, Y+
   \   00000014   9508               RET

   \                                 In  segment NEAR_Z, align 1, keep-with-next, root
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \                     ??m_xTimer:
   \   00000000                      DS8 6

   \                                 In  segment NEAR_Z, align 1, keep-with-next, root
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     22          uint8_t CDataStore::m_uiFsmState;
   \                     ??m_uiFsmState:
   \   00000000                      DS8 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next, root
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     23          uint8_t CDataStore::m_uiFsmEvent;
   \                     ??m_uiFsmEvent:
   \   00000000                      DS8 1
     24          
     25          ////-----------------------------------------------------------------------------------------------------
     26          //CDataStore::CDataStore()
     27          //{
     28          ////    m_pxStorageDevice = new CEeprom();
     29          //    m_puiIntermediateBuff = CPss21::m_auiIntermediateBuff;
     30          //    SetFsmState(IDDLE);
     31          //    SetSavedFsmState(IDDLE);
     32          //}
     33          //
     34          ////-----------------------------------------------------------------------------------------------------
     35          //CDataStore::~CDataStore()
     36          //{
     37          ////    delete m_pxStorageDevice;
     38          //}
     39          
     40          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
     41          void CDataStore::Init(void)
   \                     ??Init:
     42          {
     43              m_puiIntermediateBuff = CPss21::m_auiIntermediateBuff;
   \   00000000   ....               LDI     R16, LOW(??m_auiIntermediateBuff)
   \   00000002   ....               LDI     R17, (??m_auiIntermediateBuff) >> 8
   \   00000004   ....               LDI     R30, LOW(??m_puiIntermediateBuff)
   \   00000006   ....               LDI     R31, (??m_puiIntermediateBuff) >> 8
   \   00000008   8300               ST      Z, R16
   \   0000000A   8311               STD     Z+1, R17
     44              SetFsmState(IDDLE);
   \   0000000C   E000               LDI     R16, 0
   \   0000000E   ........           CALL    ??SetFsmState
     45          
     46              // Очистим служебный контекст.
     47              memset(reinterpret_cast<uint8_t*>(&m_xBlocksControlData),
     48                     0,
     49                     sizeof(m_xBlocksControlData));
   \   00000012   E64C               LDI     R20, 108
   \   00000014   E050               LDI     R21, 0
   \   00000016   E020               LDI     R18, 0
   \   00000018   E030               LDI     R19, 0
   \   0000001A   ....               LDI     R16, LOW(??m_xBlocksControlData)
   \   0000001C   ....               LDI     R17, (??m_xBlocksControlData) >> 8
   \   0000001E   ........           CALL    memset
     50          
     51              // Установим смещение на закодированные данные.
     52              m_xBlocksControlData.
     53              axBlockPositionData[BLOCKS_CONTROL_DATA].uiOffset = BLOCKS_CONTROL_DATA_BEGIN;
   \   00000022   ....               LDI     R30, LOW(??m_xBlocksControlData)
   \   00000024   ....               LDI     R31, (??m_xBlocksControlData) >> 8
   \   00000026   E100               LDI     R16, 16
   \   00000028   E010               LDI     R17, 0
   \   0000002A   8304               STD     Z+4, R16
   \   0000002C   8315               STD     Z+5, R17
     54              // Установим размер первичных данных.
     55              m_xBlocksControlData.
     56              axBlockPositionData[BLOCKS_CONTROL_DATA].uiLength = sizeof(struct TBlocksControlData);
   \   0000002E   ....               LDI     R30, LOW(??m_xBlocksControlData)
   \   00000030   ....               LDI     R31, (??m_xBlocksControlData) >> 8
   \   00000032   E60C               LDI     R16, 108
   \   00000034   E010               LDI     R17, 0
   \   00000036   8306               STD     Z+6, R16
   \   00000038   8317               STD     Z+7, R17
     57              // Количество байт служебного контекста
     58              // должно быть известно заранее.
     59              // Так как по нему извлекаются начальные данные.
     60              // Используется самовосстанавливающийся код Хемминга(8,4).
     61              // Коэффициент - 1.5: один байт преобразуется в кодовое слово 12 бит,
     62              // из двух байт полезных данных получается три байта кодированных.
     63              // Установим размер закодированных данных.
     64              m_xBlocksControlData.
     65              axBlockPositionData[BLOCKS_CONTROL_DATA].uiEncodedLength =
     66                  (CHammingCodes::CalculateEncodedDataLength(sizeof(struct TBlocksControlData) + CRC_LENGTH));
   \   0000003A   E60E               LDI     R16, 110
   \   0000003C   E010               LDI     R17, 0
   \   0000003E   ........           CALL    ??CalculateEncodedDataLength
   \   00000042   ....               LDI     R30, LOW(??m_xBlocksControlData)
   \   00000044   ....               LDI     R31, (??m_xBlocksControlData) >> 8
   \   00000046   8700               STD     Z+8, R16
   \   00000048   8711               STD     Z+9, R17
     67              // Установим смещение для служебного контекста.
     68              m_xBlocksControlData.uiFreeSpaceOffset =
     69                  (BLOCKS_CONTROL_DATA_BEGIN +
     70                   CHammingCodes::CalculateEncodedDataLength(sizeof(struct TBlocksControlData) + CRC_LENGTH));
   \   0000004A   E60E               LDI     R16, 110
   \   0000004C   E010               LDI     R17, 0
   \   0000004E   ........           CALL    ??CalculateEncodedDataLength
   \   00000052   5F00               SUBI    R16, 240
   \   00000054   4F1F               SBCI    R17, 255
   \   00000056   ....               LDI     R30, LOW(??m_xBlocksControlData)
   \   00000058   ....               LDI     R31, (??m_xBlocksControlData) >> 8
   \   0000005A   8302               STD     Z+2, R16
   \   0000005C   8313               STD     Z+3, R17
     71              // Установим признак - база данных не подтверждена пользователем.
     72              m_xBlocksControlData.uiCrcOfBlocksCrc = 0;
   \   0000005E   ....               LDI     R30, LOW(??m_xBlocksControlData)
   \   00000060   ....               LDI     R31, (??m_xBlocksControlData) >> 8
   \   00000062   E000               LDI     R16, 0
   \   00000064   8300               ST      Z, R16
   \   00000066   E000               LDI     R16, 0
   \   00000068   8301               STD     Z+1, R16
     73          }
   \   0000006A   9508               RET
     74          
     75          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
     76          uint16_t CDataStore::ReadBlock(uint8_t *puiDestination, uint8_t uiBlock)
   \                     ??ReadBlock:
     77          {
   \   00000000   ........           CALL    ?PROLOGUE14_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R10_is_cg_reg
   \   00000004                      REQUIRE ?Register_R11_is_cg_reg
   \   00000004                      REQUIRE ?Register_R12_is_cg_reg
   \   00000004                      REQUIRE ?Register_R13_is_cg_reg
   \   00000004   50D1               SUBI    R29, 1
   \   00000006   0138               MOVW    R7:R6, R17:R16
   \   00000008   2E82               MOV     R8, R18
     78              // Произошёл выход за границы буфера?
     79              if (uiBlock >= MAX_BLOCKS_NUMBER)
   \   0000000A   E00D               LDI     R16, 13
   \   0000000C   1680               CP      R8, R16
   \   0000000E   F018               BRCS    ??ReadBlock_1
     80              {
     81                  // Нет данных.
     82                  return 0;
   \   00000010   E000               LDI     R16, 0
   \   00000012   E010               LDI     R17, 0
   \   00000014   C077               RJMP    ??ReadBlock_2
     83              }
     84          
     85              uint16_t uiLength;
     86              uint16_t uiEncodedLength;
     87              uint16_t uiSourceOffset;
     88              uint8_t auiTempArray[256];
     89          
     90              // Блок существует?
     91              if ((m_xBlocksControlData.
     92                      axBlockPositionData[uiBlock].uiLength != 0) &&
     93                      (m_xBlocksControlData.
     94                       axBlockPositionData[uiBlock].uiEncodedLength != 0))
   \                     ??ReadBlock_1:
   \   00000016   2D08               MOV     R16, R8
   \   00000018   E010               LDI     R17, 0
   \   0000001A   E048               LDI     R20, 8
   \   0000001C   E050               LDI     R21, 0
   \   0000001E   ........           CALL    ?S_EC_MUL_L02
   \   00000022   01F8               MOVW    R31:R30, R17:R16
   \   00000024   ....               SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
   \   00000026   ....               SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
   \   00000028   8106               LDD     R16, Z+6
   \   0000002A   8117               LDD     R17, Z+7
   \   0000002C   2B01               OR      R16, R17
   \   0000002E   F409               BRNE    $+2+2
   \   00000030   C051               RJMP    ??ReadBlock_3
   \   00000032   2D08               MOV     R16, R8
   \   00000034   E010               LDI     R17, 0
   \   00000036   E048               LDI     R20, 8
   \   00000038   E050               LDI     R21, 0
   \   0000003A   ........           CALL    ?S_EC_MUL_L02
   \   0000003E   01F8               MOVW    R31:R30, R17:R16
   \   00000040   ....               SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
   \   00000042   ....               SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
   \   00000044   8500               LDD     R16, Z+8
   \   00000046   8511               LDD     R17, Z+9
   \   00000048   2B01               OR      R16, R17
   \   0000004A   F409               BRNE    $+2+2
   \   0000004C   C043               RJMP    ??ReadBlock_3
     95              {
     96                  // Получим адрес блока в EEPROM.
     97                  uiSourceOffset = m_xBlocksControlData.
     98                                   axBlockPositionData[uiBlock].uiOffset;
   \   0000004E   2D08               MOV     R16, R8
   \   00000050   E010               LDI     R17, 0
   \   00000052   E048               LDI     R20, 8
   \   00000054   E050               LDI     R21, 0
   \   00000056   ........           CALL    ?S_EC_MUL_L02
   \   0000005A   01F8               MOVW    R31:R30, R17:R16
   \   0000005C   ....               SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
   \   0000005E   ....               SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
   \   00000060   8104               LDD     R16, Z+4
   \   00000062   8115               LDD     R17, Z+5
   \   00000064   0168               MOVW    R13:R12, R17:R16
     99                  // Получим размер блока.
    100                  uiLength = m_xBlocksControlData.
    101                             axBlockPositionData[uiBlock].uiLength;
   \   00000066   2D08               MOV     R16, R8
   \   00000068   E010               LDI     R17, 0
   \   0000006A   E048               LDI     R20, 8
   \   0000006C   E050               LDI     R21, 0
   \   0000006E   ........           CALL    ?S_EC_MUL_L02
   \   00000072   01F8               MOVW    R31:R30, R17:R16
   \   00000074   ....               SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
   \   00000076   ....               SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
   \   00000078   8106               LDD     R16, Z+6
   \   0000007A   8117               LDD     R17, Z+7
   \   0000007C   0128               MOVW    R5:R4, R17:R16
    102                  // Получим размер закодированного блока.
    103                  uiEncodedLength = m_xBlocksControlData.
    104                                    axBlockPositionData[uiBlock].uiEncodedLength;
   \   0000007E   2D08               MOV     R16, R8
   \   00000080   E010               LDI     R17, 0
   \   00000082   E048               LDI     R20, 8
   \   00000084   E050               LDI     R21, 0
   \   00000086   ........           CALL    ?S_EC_MUL_L02
   \   0000008A   01F8               MOVW    R31:R30, R17:R16
   \   0000008C   ....               SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
   \   0000008E   ....               SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
   \   00000090   8500               LDD     R16, Z+8
   \   00000092   8511               LDD     R17, Z+9
   \   00000094   0158               MOVW    R11:R10, R17:R16
    105              }
    106              else
    107              {
    108                  // Нет данных.
    109                  return 0;
    110              }
    111          
    112              // Прочитаем закодированные данные.
    113              CEeprom::Read(auiTempArray, uiSourceOffset, uiEncodedLength);
   \   00000096   01A5               MOVW    R21:R20, R11:R10
   \   00000098   0196               MOVW    R19:R18, R13:R12
   \   0000009A   018E               MOVW    R17:R16, R29:R28
   \   0000009C   ........           CALL    ??Read
    114          
    115              // Декодируем прочитанные данные.
    116              CHammingCodes::HammingCodesToBytes(auiTempArray, auiTempArray, uiEncodedLength);
   \   000000A0   01A5               MOVW    R21:R20, R11:R10
   \   000000A2   019E               MOVW    R19:R18, R29:R28
   \   000000A4   018E               MOVW    R17:R16, R29:R28
   \   000000A6   ........           CALL    ??HammingCodesToBytes
    117          
    118              // Получим контрольную сумму блока.
    119              uint16_t uiCrc = static_cast<uint16_t>(auiTempArray[uiLength]);
   \   000000AA   01FE               MOVW    R31:R30, R29:R28
   \   000000AC   0DE4               ADD     R30, R4
   \   000000AE   1DF5               ADC     R31, R5
   \   000000B0   8180               LD      R24, Z
   \   000000B2   E090               LDI     R25, 0
    120              uiCrc |= (static_cast<uint16_t>(auiTempArray[uiLength + 1]) << 8);
   \   000000B4   01FE               MOVW    R31:R30, R29:R28
   \   000000B6   0DE4               ADD     R30, R4
   \   000000B8   1DF5               ADC     R31, R5
   \   000000BA   8111               LDD     R17, Z+1
   \   000000BC   E000               LDI     R16, 0
   \   000000BE   2B80               OR      R24, R16
   \   000000C0   2B91               OR      R25, R17
    121              // Вычислим контрольную сумму блока.
    122              uint16_t uiCalculatedCrc = usCrc16(auiTempArray, uiLength);
   \   000000C2   0192               MOVW    R19:R18, R5:R4
   \   000000C4   018E               MOVW    R17:R16, R29:R28
   \   000000C6   ........           CALL    ??usCrc16
   \   000000CA   01D8               MOVW    R27:R26, R17:R16
    123          
    124              // Блок не повреждён?
    125              if (uiCrc == uiCalculatedCrc)
   \   000000CC   178A               CP      R24, R26
   \   000000CE   079B               CPC     R25, R27
   \   000000D0   F4A1               BRNE    ??ReadBlock_4
   \   000000D2   C003               RJMP    ??ReadBlock_5
   \                     ??ReadBlock_3:
   \   000000D4   E000               LDI     R16, 0
   \   000000D6   E010               LDI     R17, 0
   \   000000D8   C015               RJMP    ??ReadBlock_2
    126              {
    127                  // Сохраним Crc текущего блока.
    128                  m_auiBlocksCurrentCrc[uiBlock] = uiCrc;
   \                     ??ReadBlock_5:
   \   000000DA   2D08               MOV     R16, R8
   \   000000DC   E010               LDI     R17, 0
   \   000000DE   0F00               LSL     R16
   \   000000E0   1F11               ROL     R17
   \   000000E2   01F8               MOVW    R31:R30, R17:R16
   \   000000E4   ....               SUBI    R30, LOW((-(??m_auiBlocksCurrentCrc) & 0xFFFF))
   \   000000E6   ....               SBCI    R31, (-(??m_auiBlocksCurrentCrc) & 0xFFFF) >> 8
   \   000000E8   8380               ST      Z, R24
   \   000000EA   8391               STD     Z+1, R25
    129                  memcpy(puiDestination, auiTempArray, uiLength);
   \   000000EC   01A2               MOVW    R21:R20, R5:R4
   \   000000EE   019E               MOVW    R19:R18, R29:R28
   \   000000F0   0183               MOVW    R17:R16, R7:R6
   \   000000F2   ........           CALL    memcpy
    130                  return uiLength;
   \   000000F6   0182               MOVW    R17:R16, R5:R4
   \   000000F8   C005               RJMP    ??ReadBlock_2
    131              }
    132              else
    133              {
    134                  CPss21::SetErrorCode(DB_ERROR);
   \                     ??ReadBlock_4:
   \   000000FA   E004               LDI     R16, 4
   \   000000FC   ........           CALL    ??SetErrorCode
    135                  // Нет данных.
    136                  return 0;
   \   00000100   E000               LDI     R16, 0
   \   00000102   E010               LDI     R17, 0
   \                     ??ReadBlock_2:
   \   00000104   5FDF               SUBI    R29, 255
   \   00000106   E0EE               LDI     R30, 14
   \   00000108   ........           JMP     ?EPILOGUE_B14_L09
    137              }
    138          }
    139          
    140          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    141          uint16_t CDataStore::Write(uint8_t *puiSource, uint16_t uiLength, uint8_t uiBlock)
   \                     ??Write:
    142          {
   \   00000000   ........           CALL    ?PROLOGUE10_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R9_is_cg_reg
   \   00000004   50D1               SUBI    R29, 1
   \   00000006   0128               MOVW    R5:R4, R17:R16
   \   00000008   01C9               MOVW    R25:R24, R19:R18
   \   0000000A   2E64               MOV     R6, R20
    143              // Произошёл выход за границы буфера?
    144              if (uiBlock >= MAX_BLOCKS_NUMBER)
   \   0000000C   E00D               LDI     R16, 13
   \   0000000E   1660               CP      R6, R16
   \   00000010   F018               BRCS    ??Write_1
    145              {
    146                  // Нет данных.
    147                  return 0;
   \   00000012   E000               LDI     R16, 0
   \   00000014   E010               LDI     R17, 0
   \   00000016   C07B               RJMP    ??Write_2
    148              }
    149          
    150              uint16_t uiEncodedByteCounter;
    151              uint8_t auiTempArray[256];
    152          
    153              memcpy(auiTempArray, puiSource, uiLength);
   \                     ??Write_1:
   \   00000018   01AC               MOVW    R21:R20, R25:R24
   \   0000001A   0192               MOVW    R19:R18, R5:R4
   \   0000001C   018E               MOVW    R17:R16, R29:R28
   \   0000001E   ........           CALL    memcpy
    154              // Вычислим контрольную сумму поступивших данных.
    155              uint16_t uiCrc = usCrc16(puiSource, uiLength);
   \   00000022   019C               MOVW    R19:R18, R25:R24
   \   00000024   0182               MOVW    R17:R16, R5:R4
   \   00000026   ........           CALL    ??usCrc16
   \   0000002A   01D8               MOVW    R27:R26, R17:R16
    156              auiTempArray[uiLength] = static_cast<uint8_t>(uiCrc);
   \   0000002C   2F0A               MOV     R16, R26
   \   0000002E   01FE               MOVW    R31:R30, R29:R28
   \   00000030   0FE8               ADD     R30, R24
   \   00000032   1FF9               ADC     R31, R25
   \   00000034   8300               ST      Z, R16
    157              auiTempArray[uiLength + 1] = static_cast<uint8_t>(uiCrc >> 8);
   \   00000036   018D               MOVW    R17:R16, R27:R26
   \   00000038   2F01               MOV     R16, R17
   \   0000003A   E010               LDI     R17, 0
   \   0000003C   01FE               MOVW    R31:R30, R29:R28
   \   0000003E   0FE8               ADD     R30, R24
   \   00000040   1FF9               ADC     R31, R25
   \   00000042   8301               STD     Z+1, R16
    158          
    159              m_xBlocksControlData.
    160              axBlockPositionData[uiBlock].uiCrc = uiCrc;
   \   00000044   2D06               MOV     R16, R6
   \   00000046   E010               LDI     R17, 0
   \   00000048   E048               LDI     R20, 8
   \   0000004A   E050               LDI     R21, 0
   \   0000004C   ........           CALL    ?S_EC_MUL_L02
   \   00000050   01F8               MOVW    R31:R30, R17:R16
   \   00000052   ....               SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
   \   00000054   ....               SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
   \   00000056   87A2               STD     Z+10, R26
   \   00000058   87B3               STD     Z+11, R27
    161          
    162              uiEncodedByteCounter =
    163                  CHammingCodes::BytesToHammingCodes(m_puiIntermediateBuff, auiTempArray, (uiLength + CRC_LENGTH));
   \   0000005A   01AC               MOVW    R21:R20, R25:R24
   \   0000005C   5F4E               SUBI    R20, 254
   \   0000005E   4F5F               SBCI    R21, 255
   \   00000060   019E               MOVW    R19:R18, R29:R28
   \   00000062   ....               LDI     R30, LOW(??m_puiIntermediateBuff)
   \   00000064   ....               LDI     R31, (??m_puiIntermediateBuff) >> 8
   \   00000066   8100               LD      R16, Z
   \   00000068   8111               LDD     R17, Z+1
   \   0000006A   ........           CALL    ??BytesToHammingCodes
   \   0000006E   0148               MOVW    R9:R8, R17:R16
    164          
    165              // Данные текущего блока данных - uiBlock сохраняются впервые?
    166              if (m_xBlocksControlData.
    167                      axBlockPositionData[uiBlock].uiEncodedLength == 0)
   \   00000070   2D06               MOV     R16, R6
   \   00000072   E010               LDI     R17, 0
   \   00000074   E048               LDI     R20, 8
   \   00000076   E050               LDI     R21, 0
   \   00000078   ........           CALL    ?S_EC_MUL_L02
   \   0000007C   01F8               MOVW    R31:R30, R17:R16
   \   0000007E   ....               SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
   \   00000080   ....               SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
   \   00000082   8500               LDD     R16, Z+8
   \   00000084   8511               LDD     R17, Z+9
   \   00000086   2B01               OR      R16, R17
   \   00000088   F569               BRNE    ??Write_3
    168              {
    169                  // Добавили новый блок данных.
    170                  // Сохраним смещение на блок.
    171                  m_xBlocksControlData.
    172                  axBlockPositionData[uiBlock].uiOffset = m_xBlocksControlData.uiFreeSpaceOffset;
   \   0000008A   ....               LDI     R30, LOW(??m_xBlocksControlData)
   \   0000008C   ....               LDI     R31, (??m_xBlocksControlData) >> 8
   \   0000008E   8122               LDD     R18, Z+2
   \   00000090   8133               LDD     R19, Z+3
   \   00000092   2D06               MOV     R16, R6
   \   00000094   E010               LDI     R17, 0
   \   00000096   E048               LDI     R20, 8
   \   00000098   E050               LDI     R21, 0
   \   0000009A   ........           CALL    ?S_EC_MUL_L02
   \   0000009E   01F8               MOVW    R31:R30, R17:R16
   \   000000A0   ....               SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
   \   000000A2   ....               SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
   \   000000A4   8324               STD     Z+4, R18
   \   000000A6   8335               STD     Z+5, R19
    173                  // Изменим смещение на свободное место.
    174                  m_xBlocksControlData.uiFreeSpaceOffset += uiEncodedByteCounter;
   \   000000A8   ....               LDI     R30, LOW(??m_xBlocksControlData)
   \   000000AA   ....               LDI     R31, (??m_xBlocksControlData) >> 8
   \   000000AC   8102               LDD     R16, Z+2
   \   000000AE   8113               LDD     R17, Z+3
   \   000000B0   0D08               ADD     R16, R8
   \   000000B2   1D19               ADC     R17, R9
   \   000000B4   8302               STD     Z+2, R16
   \   000000B6   8313               STD     Z+3, R17
    175                  // Сохраним размер первичных данных.
    176                  m_xBlocksControlData.
    177                  axBlockPositionData[uiBlock].uiLength = uiLength;
   \   000000B8   2D06               MOV     R16, R6
   \   000000BA   E010               LDI     R17, 0
   \   000000BC   E048               LDI     R20, 8
   \   000000BE   E050               LDI     R21, 0
   \   000000C0   ........           CALL    ?S_EC_MUL_L02
   \   000000C4   01F8               MOVW    R31:R30, R17:R16
   \   000000C6   ....               SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
   \   000000C8   ....               SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
   \   000000CA   8386               STD     Z+6, R24
   \   000000CC   8397               STD     Z+7, R25
    178                  // Сохраним размер закодированных данных.
    179                  m_xBlocksControlData.
    180                  axBlockPositionData[uiBlock].uiEncodedLength = uiEncodedByteCounter;
   \   000000CE   2D06               MOV     R16, R6
   \   000000D0   E010               LDI     R17, 0
   \   000000D2   E048               LDI     R20, 8
   \   000000D4   E050               LDI     R21, 0
   \   000000D6   ........           CALL    ?S_EC_MUL_L02
   \   000000DA   01F8               MOVW    R31:R30, R17:R16
   \   000000DC   ....               SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
   \   000000DE   ....               SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
   \   000000E0   8680               STD     Z+8, R8
   \   000000E2   8691               STD     Z+9, R9
    181              }
    182          
    183              CEeprom::WriteInterrupt(m_xBlocksControlData.
    184                                      axBlockPositionData[uiBlock].uiOffset,
    185                                      m_puiIntermediateBuff,
    186                                      uiEncodedByteCounter);
   \                     ??Write_3:
   \   000000E4   01A4               MOVW    R21:R20, R9:R8
   \   000000E6   ....               LDI     R30, LOW(??m_puiIntermediateBuff)
   \   000000E8   ....               LDI     R31, (??m_puiIntermediateBuff) >> 8
   \   000000EA   8120               LD      R18, Z
   \   000000EC   8131               LDD     R19, Z+1
   \   000000EE   01BA               MOVW    R23:R22, R21:R20
   \   000000F0   2D06               MOV     R16, R6
   \   000000F2   E010               LDI     R17, 0
   \   000000F4   E048               LDI     R20, 8
   \   000000F6   E050               LDI     R21, 0
   \   000000F8   ........           CALL    ?S_EC_MUL_L02
   \   000000FC   01F8               MOVW    R31:R30, R17:R16
   \   000000FE   ....               SUBI    R30, LOW((-(??m_xBlocksControlData) & 0xFFFF))
   \   00000100   ....               SBCI    R31, (-(??m_xBlocksControlData) & 0xFFFF) >> 8
   \   00000102   8104               LDD     R16, Z+4
   \   00000104   8115               LDD     R17, Z+5
   \   00000106   01AB               MOVW    R21:R20, R23:R22
   \   00000108   ........           CALL    ??WriteInterrupt
    187          
    188              // Out length.
    189              return uiEncodedByteCounter;
   \   0000010C   0184               MOVW    R17:R16, R9:R8
   \                     ??Write_2:
   \   0000010E   5FDF               SUBI    R29, 255
   \   00000110   E0EA               LDI     R30, 10
   \   00000112   ........           JMP     ?EPILOGUE_B10_L09
    190          }
    191          
    192          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    193          bool CDataStore::WriteBlock(uint8_t *puiSource, uint16_t uiLength, uint8_t uiBlock)
   \                     ??WriteBlock:
    194          {
   \   00000000   ........           CALL    ?PROLOGUE5_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004   01D8               MOVW    R27:R26, R17:R16
   \   00000006   01C9               MOVW    R25:R24, R19:R18
   \   00000008   2E44               MOV     R4, R20
    195              if (GetFsmState() == IDDLE)
   \   0000000A   ........           CALL    ??GetFsmState
   \   0000000E   2300               TST     R16
   \   00000010   F499               BRNE    ??WriteBlock_1
    196              {
    197                  if (Write(puiSource,
    198                            uiLength,
    199                            uiBlock))
   \   00000012   2D44               MOV     R20, R4
   \   00000014   019C               MOVW    R19:R18, R25:R24
   \   00000016   018D               MOVW    R17:R16, R27:R26
   \   00000018   ....               RCALL   ??Write
   \   0000001A   2B01               OR      R16, R17
   \   0000001C   F041               BREQ    ??WriteBlock_2
    200                  {
    201                      SetFsmEvent(WRITE_IN_PROGRESS_FSM_EVENT);
   \   0000001E   E001               LDI     R16, 1
   \   00000020   ........           CALL    ??SetFsmEvent
    202                      SetFsmState(START_WRITE);
   \   00000024   E001               LDI     R16, 1
   \   00000026   ........           CALL    ??SetFsmState
    203                      return true;
   \   0000002A   E001               LDI     R16, 1
   \   0000002C   C009               RJMP    ??WriteBlock_3
    204                  }
    205                  else
    206                  {
    207                      SetFsmEvent(WRITE_ERROR_FSM_EVENT);
   \                     ??WriteBlock_2:
   \   0000002E   E004               LDI     R16, 4
   \   00000030   ........           CALL    ??SetFsmEvent
    208                      return false;
   \   00000034   E000               LDI     R16, 0
   \   00000036   C004               RJMP    ??WriteBlock_3
    209                  }
    210              }
    211              else
    212              {
    213                  SetFsmEvent(STORAGE_DEVICE_BUSY_FSM_EVENT);
   \                     ??WriteBlock_1:
   \   00000038   E002               LDI     R16, 2
   \   0000003A   ........           CALL    ??SetFsmEvent
    214                  return false;
   \   0000003E   E000               LDI     R16, 0
   \                     ??WriteBlock_3:
   \   00000040   E0E5               LDI     R30, 5
   \   00000042   ........           JMP     ?EPILOGUE_B5_L09
    215              }
    216          }
    217          
    218          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    219          bool CDataStore::CompareCurrentWithStoredCrc(void)
   \                     ??CompareCurrentWithStoredCrc:
    220          {
   \   00000000   01BD               MOVW    R23:R22, R27:R26
    221              // Сравним текущее Crc блока с его Crc сохранённом в служебном блоке в предыдущей сессии записи.
    222              for (uint16_t i = BLOCKS_CONTROL_DATA_BLOCK_NUMBER;
   \   00000002   E0E1               LDI     R30, 1
   \   00000004   E0F0               LDI     R31, 0
    223                      i < (MAX_BLOCKS_NUMBER - BLOCKS_CONTROL_DATA_BLOCK_NUMBER);
   \                     ??CompareCurrentWithStoredCrc_1:
   \   00000006   30EC               CPI     R30, 12
   \   00000008   E000               LDI     R16, 0
   \   0000000A   07F0               CPC     R31, R16
   \   0000000C   F4D8               BRCC    ??CompareCurrentWithStoredCrc_2
    224                      i++)
    225              {
    226                  if (m_auiBlocksCurrentCrc[i] !=
    227                          m_xBlocksControlData.axBlockPositionData[i].uiCrc)
   \   0000000E   018F               MOVW    R17:R16, R31:R30
   \   00000010   0F00               LSL     R16
   \   00000012   1F11               ROL     R17
   \   00000014   01D8               MOVW    R27:R26, R17:R16
   \   00000016   ....               SUBI    R26, LOW((-(??m_auiBlocksCurrentCrc) & 0xFFFF))
   \   00000018   ....               SBCI    R27, (-(??m_auiBlocksCurrentCrc) & 0xFFFF) >> 8
   \   0000001A   912D               LD      R18, X+
   \   0000001C   913C               LD      R19, X
   \   0000001E   9711               SBIW    R27:R26, 1
   \   00000020   018F               MOVW    R17:R16, R31:R30
   \   00000022   E048               LDI     R20, 8
   \   00000024   E050               LDI     R21, 0
   \   00000026   ........           CALL    ?S_EC_MUL_L02
   \   0000002A   01D8               MOVW    R27:R26, R17:R16
   \   0000002C   ....               SUBI    R26, LOW((-(??m_xBlocksControlData + 10) & 0xFFFF))
   \   0000002E   ....               SBCI    R27, HIGH((-(??m_xBlocksControlData + 10) & 0xFFFF))
   \   00000030   910D               LD      R16, X+
   \   00000032   911C               LD      R17, X
   \   00000034   9711               SBIW    R27:R26, 1
   \   00000036   1720               CP      R18, R16
   \   00000038   0731               CPC     R19, R17
   \   0000003A   F011               BREQ    ??CompareCurrentWithStoredCrc_3
    228                  {
    229                      return false;
   \   0000003C   E000               LDI     R16, 0
   \   0000003E   C003               RJMP    ??CompareCurrentWithStoredCrc_4
    230                  }
    231              }
   \                     ??CompareCurrentWithStoredCrc_3:
   \   00000040   9631               ADIW    R31:R30, 1
   \   00000042   CFE1               RJMP    ??CompareCurrentWithStoredCrc_1
    232          
    233              // Все блоки принадлежат текущей базе данных.
    234              return true;
   \                     ??CompareCurrentWithStoredCrc_2:
   \   00000044   E001               LDI     R16, 1
   \                     ??CompareCurrentWithStoredCrc_4:
   \   00000046   01DB               MOVW    R27:R26, R23:R22
   \   00000048   9508               RET
    235          }
    236          
    237          //-----------------------------------------------------------------------------------------------------
    238          // Вызывается только если база данных подтверждена пользователем.

   \                                 In  segment CODE, align 2, keep-with-next
    239          void CDataStore::CrcOfBlocksCrcCreate(void)
   \                     ??CrcOfBlocksCrcCreate:
    240          {
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   9768               SBIW    R29:R28, 24
    241              // Контрольная сумма вычисленная из массива контрольных сумм блоков, не включая служебный.
    242              // Сохраняется при первой и последующих записях любых блоков через программатор.
    243              // Ноль или её несовпадение свидетельствует о том, что база данных создана по умоланию,
    244              // и не подтверждена пользователем. В этом случае прибор переходит в режим сигнализации об ошибке,
    245              // ожидая квитирования или записи базы данных.
    246              uint16_t auiBlocksCrc[MAX_BLOCKS_NUMBER - BLOCKS_CONTROL_DATA_BLOCK_NUMBER];
    247          
    248              // Получим Crc всех блоков, не включая служебный.
    249              for (uint16_t i = 0;
   \   00000006   E0E0               LDI     R30, 0
   \   00000008   E0F0               LDI     R31, 0
    250                      i < (MAX_BLOCKS_NUMBER - BLOCKS_CONTROL_DATA_BLOCK_NUMBER);
   \                     ??CrcOfBlocksCrcCreate_1:
   \   0000000A   30EC               CPI     R30, 12
   \   0000000C   E000               LDI     R16, 0
   \   0000000E   07F0               CPC     R31, R16
   \   00000010   F4B0               BRCC    ??CrcOfBlocksCrcCreate_2
    251                      i++)
    252              {
    253                  auiBlocksCrc[i] =
    254                      m_xBlocksControlData.axBlockPositionData[i + BLOCKS_CONTROL_DATA_BLOCK_NUMBER].uiCrc;
   \   00000012   018F               MOVW    R17:R16, R31:R30
   \   00000014   E048               LDI     R20, 8
   \   00000016   E050               LDI     R21, 0
   \   00000018   ........           CALL    ?S_EC_MUL_L02
   \   0000001C   01D8               MOVW    R27:R26, R17:R16
   \   0000001E   ....               SUBI    R26, LOW((-(??m_xBlocksControlData + 18) & 0xFFFF))
   \   00000020   ....               SBCI    R27, HIGH((-(??m_xBlocksControlData + 18) & 0xFFFF))
   \   00000022   912D               LD      R18, X+
   \   00000024   913C               LD      R19, X
   \   00000026   9711               SBIW    R27:R26, 1
   \   00000028   01DE               MOVW    R27:R26, R29:R28
   \   0000002A   018F               MOVW    R17:R16, R31:R30
   \   0000002C   0F00               LSL     R16
   \   0000002E   1F11               ROL     R17
   \   00000030   0FA0               ADD     R26, R16
   \   00000032   1FB1               ADC     R27, R17
   \   00000034   932D               ST      X+, R18
   \   00000036   933C               ST      X, R19
   \   00000038   9711               SBIW    R27:R26, 1
    255              }
   \   0000003A   9631               ADIW    R31:R30, 1
   \   0000003C   CFE6               RJMP    ??CrcOfBlocksCrcCreate_1
    256          
    257              // Сохраним Crc всех блоков, не включая служебный.
    258              m_xBlocksControlData.uiCrcOfBlocksCrc =
    259                  usCrc16(reinterpret_cast<uint8_t*>(auiBlocksCrc),
    260                          ((MAX_BLOCKS_NUMBER - BLOCKS_CONTROL_DATA_BLOCK_NUMBER) * sizeof(uint16_t)));
   \                     ??CrcOfBlocksCrcCreate_2:
   \   0000003E   E128               LDI     R18, 24
   \   00000040   E030               LDI     R19, 0
   \   00000042   018E               MOVW    R17:R16, R29:R28
   \   00000044   ........           CALL    ??usCrc16
   \   00000048   ....               LDI     R30, LOW(??m_xBlocksControlData)
   \   0000004A   ....               LDI     R31, (??m_xBlocksControlData) >> 8
   \   0000004C   8300               ST      Z, R16
   \   0000004E   8311               STD     Z+1, R17
    261          
    262          }
   \   00000050   9668               ADIW    R29:R28, 24
   \   00000052   91A9               LD      R26, Y+
   \   00000054   91B9               LD      R27, Y+
   \   00000056   9508               RET
    263          
    264          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    265          bool CDataStore::CrcOfBlocksCrcCheck(void)
   \                     ??CrcOfBlocksCrcCheck:
    266          {
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   9768               SBIW    R29:R28, 24
    267              // Контрольная сумма вычисленная из массива контрольных сумм блоков, не включая служебный.
    268              // Сохраняется при первой и последующих записях любых блоков через программатор.
    269              // Ноль или её несовпадение свидетельствует о том, что база данных создана по умоланию,
    270              // и не подтверждена пользователем. В этом случае прибор переходит в режим сигнализации об ошибке,
    271              // ожидая квитирования или записи базы данных.
    272              uint16_t auiBlocksCrc[MAX_BLOCKS_NUMBER - BLOCKS_CONTROL_DATA_BLOCK_NUMBER];
    273          
    274              // Получим Crc всех блоков, не включая служебный.
    275              for (uint16_t i = 0;
   \   00000006   E0E0               LDI     R30, 0
   \   00000008   E0F0               LDI     R31, 0
    276                      i < (MAX_BLOCKS_NUMBER - BLOCKS_CONTROL_DATA_BLOCK_NUMBER);
   \                     ??CrcOfBlocksCrcCheck_1:
   \   0000000A   30EC               CPI     R30, 12
   \   0000000C   E000               LDI     R16, 0
   \   0000000E   07F0               CPC     R31, R16
   \   00000010   F4B0               BRCC    ??CrcOfBlocksCrcCheck_2
    277                      i++)
    278              {
    279                  auiBlocksCrc[i] =
    280                      m_xBlocksControlData.axBlockPositionData[i + BLOCKS_CONTROL_DATA_BLOCK_NUMBER].uiCrc;
   \   00000012   018F               MOVW    R17:R16, R31:R30
   \   00000014   E048               LDI     R20, 8
   \   00000016   E050               LDI     R21, 0
   \   00000018   ........           CALL    ?S_EC_MUL_L02
   \   0000001C   01D8               MOVW    R27:R26, R17:R16
   \   0000001E   ....               SUBI    R26, LOW((-(??m_xBlocksControlData + 18) & 0xFFFF))
   \   00000020   ....               SBCI    R27, HIGH((-(??m_xBlocksControlData + 18) & 0xFFFF))
   \   00000022   912D               LD      R18, X+
   \   00000024   913C               LD      R19, X
   \   00000026   9711               SBIW    R27:R26, 1
   \   00000028   01DE               MOVW    R27:R26, R29:R28
   \   0000002A   018F               MOVW    R17:R16, R31:R30
   \   0000002C   0F00               LSL     R16
   \   0000002E   1F11               ROL     R17
   \   00000030   0FA0               ADD     R26, R16
   \   00000032   1FB1               ADC     R27, R17
   \   00000034   932D               ST      X+, R18
   \   00000036   933C               ST      X, R19
   \   00000038   9711               SBIW    R27:R26, 1
    281              }
   \   0000003A   9631               ADIW    R31:R30, 1
   \   0000003C   CFE6               RJMP    ??CrcOfBlocksCrcCheck_1
    282          
    283              // Crc из Crc всех блоков совпадает с сохранённым в служебном блоке?
    284              if (m_xBlocksControlData.uiCrcOfBlocksCrc ==
    285                      usCrc16(reinterpret_cast<uint8_t*>(auiBlocksCrc),
    286                              ((MAX_BLOCKS_NUMBER - BLOCKS_CONTROL_DATA_BLOCK_NUMBER) * sizeof(uint16_t))))
   \                     ??CrcOfBlocksCrcCheck_2:
   \   0000003E   E128               LDI     R18, 24
   \   00000040   E030               LDI     R19, 0
   \   00000042   018E               MOVW    R17:R16, R29:R28
   \   00000044   ........           CALL    ??usCrc16
   \   00000048   ....               LDI     R30, LOW(??m_xBlocksControlData)
   \   0000004A   ....               LDI     R31, (??m_xBlocksControlData) >> 8
   \   0000004C   8120               LD      R18, Z
   \   0000004E   8131               LDD     R19, Z+1
   \   00000050   1720               CP      R18, R16
   \   00000052   0731               CPC     R19, R17
   \   00000054   F411               BRNE    ??CrcOfBlocksCrcCheck_3
    287              {
    288                  return true;
   \   00000056   E001               LDI     R16, 1
   \   00000058   C001               RJMP    ??CrcOfBlocksCrcCheck_4
    289              }
    290              else
    291              {
    292                  return false;
   \                     ??CrcOfBlocksCrcCheck_3:
   \   0000005A   E000               LDI     R16, 0
   \                     ??CrcOfBlocksCrcCheck_4:
   \   0000005C   9668               ADIW    R29:R28, 24
   \   0000005E   91A9               LD      R26, Y+
   \   00000060   91B9               LD      R27, Y+
   \   00000062   9508               RET
    293              }
    294          }
    295          
    296          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    297          uint8_t CDataStore::Check(void)
   \                     ??Check:
    298          {
   \   00000000   ........           CALL    ?PROLOGUE4_L09
    299              CDataStore::Init();
   \   00000004   ....               RCALL   ??Init
    300          
    301              // Служебный блок повреждён?
    302              if (!(ReadBlock(reinterpret_cast<uint8_t*>(&m_xBlocksControlData), BLOCKS_CONTROL_DATA)))
   \   00000006   E020               LDI     R18, 0
   \   00000008   ....               LDI     R16, LOW(??m_xBlocksControlData)
   \   0000000A   ....               LDI     R17, (??m_xBlocksControlData) >> 8
   \   0000000C   ....               RCALL   ??ReadBlock
   \   0000000E   2B01               OR      R16, R17
   \   00000010   F411               BRNE    ??Check_1
    303              {
    304                  return 0;
   \   00000012   E000               LDI     R16, 0
   \   00000014   C057               RJMP    ??Check_2
    305              }
    306          
    307              enum
    308              {
    309                  IDDLE = 0,
    310                  BLOCK_CHECK_START,
    311                  BLOCK_WRITE_START,
    312                  BLOCK_WRITE_END_WAITING,
    313                  NEXT_BLOCK,
    314                  BLOCK_ERROR,
    315                  ALL_BLOCKS_CHECKED,
    316              };
    317          
    318              uint8_t uiBlockCounter = 0;
   \                     ??Check_1:
   \   00000016   E0B0               LDI     R27, 0
    319              uint8_t uiFsmState = BLOCK_CHECK_START;
   \   00000018   E0A1               LDI     R26, 1
    320              uint16_t uiLength;
    321          
    322              CHammingCodes::SetErrorCode(CHammingCodes::NONE_ERROR);
   \   0000001A   E000               LDI     R16, 0
   \   0000001C   ........           CALL    ??SetErrorCode_1
    323          
    324              while (1)
    325              {
    326                  switch (uiFsmState)
   \                     ??Check_3:
   \   00000020   2F0A               MOV     R16, R26
   \   00000022   5001               SUBI    R16, 1
   \   00000024   F059               BREQ    ??Check_4
   \   00000026   950A               DEC     R16
   \   00000028   F109               BREQ    ??Check_5
   \   0000002A   950A               DEC     R16
   \   0000002C   F181               BREQ    ??Check_6
   \   0000002E   950A               DEC     R16
   \   00000030   F1D1               BREQ    ??Check_7
   \   00000032   950A               DEC     R16
   \   00000034   F1E9               BREQ    ??Check_8
   \   00000036   950A               DEC     R16
   \   00000038   F1C9               BREQ    ??Check_9
   \   0000003A   C03C               RJMP    ??Check_10
    327                  {
    328                  case BLOCK_CHECK_START:
    329                      // Проверены не все блоки?
    330                      if (uiBlockCounter < MAX_BLOCKS_NUMBER)
   \                     ??Check_4:
   \   0000003C   30BD               CPI     R27, 13
   \   0000003E   F4A0               BRCC    ??Check_11
    331                      {
    332                          uiLength = ReadBlock(m_puiIntermediateBuff, uiBlockCounter);
   \   00000040   2F2B               MOV     R18, R27
   \   00000042   ....               LDI     R30, LOW(??m_puiIntermediateBuff)
   \   00000044   ....               LDI     R31, (??m_puiIntermediateBuff) >> 8
   \   00000046   8100               LD      R16, Z
   \   00000048   8111               LDD     R17, Z+1
   \   0000004A   ....               RCALL   ??ReadBlock
   \   0000004C   01C8               MOVW    R25:R24, R17:R16
    333                          // Блок не повреждён?
    334                          if (uiLength)
   \   0000004E   2F08               MOV     R16, R24
   \   00000050   2B09               OR      R16, R25
   \   00000052   F041               BREQ    ??Check_12
    335                          {
    336                              // Блок восстановлен после обнаружения ошибки?
    337                              if (CHammingCodes::GetErrorCode() != CHammingCodes::NONE_ERROR)
   \   00000054   ........           CALL    ??GetErrorCode
   \   00000058   2300               TST     R16
   \   0000005A   F011               BREQ    ??Check_13
    338                              {
    339                                  // Обновим восстановленный блок в хранилище.
    340                                  uiFsmState = BLOCK_WRITE_START;
   \   0000005C   E0A2               LDI     R26, 2
   \   0000005E   C02A               RJMP    ??Check_10
    341                              }
    342                              else
    343                              {
    344                                  uiFsmState = NEXT_BLOCK;
   \                     ??Check_13:
   \   00000060   E0A4               LDI     R26, 4
   \   00000062   C028               RJMP    ??Check_10
    345                              }
    346                          }
    347                          else
    348                          {
    349                              uiFsmState = BLOCK_ERROR;
   \                     ??Check_12:
   \   00000064   E0A5               LDI     R26, 5
   \   00000066   C026               RJMP    ??Check_10
    350                          }
    351                      }
    352                      else
    353                      {
    354                          uiFsmState = ALL_BLOCKS_CHECKED;
   \                     ??Check_11:
   \   00000068   E0A6               LDI     R26, 6
    355                      }
    356                      break;
   \   0000006A   C024               RJMP    ??Check_10
    357          
    358                  case BLOCK_WRITE_START:
    359                      // Поместим данные в хранилище.
    360                      // Блок БД принят к записи?
    361                      if (WriteBlock(m_puiIntermediateBuff, uiLength, uiBlockCounter))
   \                     ??Check_5:
   \   0000006C   2F4B               MOV     R20, R27
   \   0000006E   019C               MOVW    R19:R18, R25:R24
   \   00000070   ....               LDI     R30, LOW(??m_puiIntermediateBuff)
   \   00000072   ....               LDI     R31, (??m_puiIntermediateBuff) >> 8
   \   00000074   8100               LD      R16, Z
   \   00000076   8111               LDD     R17, Z+1
   \   00000078   ....               RCALL   ??WriteBlock
   \   0000007A   2300               TST     R16
   \   0000007C   F011               BREQ    ??Check_14
    362                      {
    363                          uiFsmState = BLOCK_WRITE_END_WAITING;
   \   0000007E   E0A3               LDI     R26, 3
   \   00000080   C019               RJMP    ??Check_10
    364                      }
    365                      // При записи блока БД произошла ошибка?
    366                      else if (CDataStore::GetFsmEvent() == CDataStore::WRITE_ERROR_FSM_EVENT)
   \                     ??Check_14:
   \   00000082   ........           CALL    ??GetFsmEvent
   \   00000086   3004               CPI     R16, 4
   \   00000088   F4A9               BRNE    ??Check_10
    367                      {
    368                          uiFsmState = BLOCK_ERROR;
   \   0000008A   E0A5               LDI     R26, 5
    369                      }
    370                      break;
   \   0000008C   C013               RJMP    ??Check_10
    371          
    372                  case BLOCK_WRITE_END_WAITING:
    373                      // Блок записан успешно?
    374                      if (CDataStore::GetFsmEvent() == CDataStore::WRITE_OK_FSM_EVENT)
   \                     ??Check_6:
   \   0000008E   ........           CALL    ??GetFsmEvent
   \   00000092   3003               CPI     R16, 3
   \   00000094   F411               BRNE    ??Check_15
    375                      {
    376                          uiFsmState = NEXT_BLOCK;
   \   00000096   E0A4               LDI     R26, 4
   \   00000098   C00D               RJMP    ??Check_10
    377                      }
    378                      // При записи блока БД произошла ошибка?
    379                      else if (CDataStore::GetFsmEvent() == CDataStore::WRITE_ERROR_FSM_EVENT)
   \                     ??Check_15:
   \   0000009A   ........           CALL    ??GetFsmEvent
   \   0000009E   3004               CPI     R16, 4
   \   000000A0   F449               BRNE    ??Check_10
    380                      {
    381                          uiFsmState = BLOCK_ERROR;
   \   000000A2   E0A5               LDI     R26, 5
    382                      }
    383                      break;
   \   000000A4   C007               RJMP    ??Check_10
    384          
    385                  case NEXT_BLOCK:
    386                      uiBlockCounter++;
   \                     ??Check_7:
   \   000000A6   95B3               INC     R27
    387                      uiFsmState = BLOCK_CHECK_START;
   \   000000A8   E0A1               LDI     R26, 1
    388                      break;
   \   000000AA   C004               RJMP    ??Check_10
    389          
    390                  case ALL_BLOCKS_CHECKED:
    391                      // данные не повреждены.
    392                      return 1;
   \                     ??Check_9:
   \   000000AC   E001               LDI     R16, 1
   \   000000AE   C00A               RJMP    ??Check_2
    393                      break;
    394          
    395                  case BLOCK_ERROR:
    396                      return 0;
   \                     ??Check_8:
   \   000000B0   E000               LDI     R16, 0
   \   000000B2   C008               RJMP    ??Check_2
    397                      break;
    398          
    399                  default:
    400                      break;
    401                  }
    402          
    403                  CDataStore::Fsm();
   \                     ??Check_10:
   \   000000B4   ....               RCALL   ??Fsm
    404          
    405                  delay_ms(10);
   \   000000B6   E00A               LDI     R16, 10
   \   000000B8   E010               LDI     R17, 0
   \   000000BA   ........           CALL    ??delay_ms
    406          
    407                  CPlatform::WatchdogReset();
   \   000000BE   ........           CALL    ??WatchdogReset
   \   000000C2   CFAE               RJMP    ??Check_3
    408              }
   \                     ??Check_2:
   \   000000C4   E0E4               LDI     R30, 4
   \   000000C6   ........           JMP     ?EPILOGUE_B4_L09
    409          }
    410          
    411          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    412          void CDataStore::Fsm(void)
   \                     ??Fsm:
    413          {
    414              switch (GetFsmState())
   \   00000000   ........           CALL    ??GetFsmState
   \   00000004   5000               SUBI    R16, 0
   \   00000006   F079               BREQ    ??Fsm_1
   \   00000008   950A               DEC     R16
   \   0000000A   F071               BREQ    ??Fsm_2
   \   0000000C   950A               DEC     R16
   \   0000000E   F0B1               BREQ    ??Fsm_3
   \   00000010   950A               DEC     R16
   \   00000012   F189               BREQ    ??Fsm_4
   \   00000014   950A               DEC     R16
   \   00000016   F409               BRNE    $+2+2
   \   00000018   C043               RJMP    ??Fsm_5
   \   0000001A   950A               DEC     R16
   \   0000001C   F409               BRNE    $+2+2
   \   0000001E   C059               RJMP    ??Fsm_6
   \   00000020   950A               DEC     R16
   \   00000022   F409               BRNE    $+2+2
   \   00000024   C073               RJMP    ??Fsm_7
    415              {
    416              case IDDLE:
    417                  break;
   \                     ??Fsm_1:
   \   00000026   9508               RET
    418          
    419              case START_WRITE:
    420                  // Установим время ожидания готовности к записи.
    421                  GetTimerPointer() -> Set(READY_TO_WRITE_WAITING_TIMEOUT);
   \                     ??Fsm_2:
   \   00000028   ........           CALL    ??GetTimerPointer
   \   0000002C   EC28               LDI     R18, 200
   \   0000002E   E030               LDI     R19, 0
   \   00000030   ........           CALL    ??Set
    422                  SetFsmState(READY_TO_WRITE_WAITING);
   \   00000034   E002               LDI     R16, 2
   \   00000036   ........           CALL    ??SetFsmState
    423                  break;
   \   0000003A   9508               RET
    424          
    425              case READY_TO_WRITE_WAITING:
    426                  if (CEeprom::IsReadyToWrite())
   \                     ??Fsm_3:
   \   0000003C   ........           CALL    ??IsReadyToWrite
   \   00000040   2300               TST     R16
   \   00000042   F061               BREQ    ??Fsm_8
    427                  {
    428                      // Установим время ожидания окончания записи записи.
    429                      GetTimerPointer() -> Set(WRITE_END_WAITING_TIMEOUT);
   \   00000044   ........           CALL    ??GetTimerPointer
   \   00000048   E120               LDI     R18, 16
   \   0000004A   E237               LDI     R19, 39
   \   0000004C   ........           CALL    ??Set
    430                      CEeprom::StartWrite();
   \   00000050   ........           CALL    ??StartWrite
    431                      SetFsmState(WRITE_END_WAITING);
   \   00000054   E003               LDI     R16, 3
   \   00000056   ........           CALL    ??SetFsmState
   \   0000005A   9508               RET
    432                  }
    433                  // Время ожидания готовности к записи закончилось?
    434                  else if (GetTimerPointer() -> IsOverflow())
   \                     ??Fsm_8:
   \   0000005C   ........           CALL    ??GetTimerPointer
   \   00000060   ........           CALL    ??IsOverflow
   \   00000064   2300               TST     R16
   \   00000066   F031               BREQ    ??Fsm_9
    435                  {
    436                      SetFsmEvent(WRITE_ERROR_FSM_EVENT);
   \   00000068   E004               LDI     R16, 4
   \   0000006A   ........           CALL    ??SetFsmEvent
    437                      SetFsmState(IDDLE);
   \   0000006E   E000               LDI     R16, 0
   \   00000070   ........           CALL    ??SetFsmState
    438                  }
    439                  break;
   \                     ??Fsm_9:
   \   00000074   9508               RET
    440          
    441              case WRITE_END_WAITING:
    442                  if (CEeprom::GetBufferIsWrited())
   \                     ??Fsm_4:
   \   00000076   ........           CALL    ??GetBufferIsWrited
   \   0000007A   2300               TST     R16
   \   0000007C   F021               BREQ    ??Fsm_10
    443                  {
    444                      SetFsmState(START_WRITE_BLOCKS_CONTROL_DATA);
   \   0000007E   E004               LDI     R16, 4
   \   00000080   ........           CALL    ??SetFsmState
   \   00000084   9508               RET
    445                  }
    446                  // Время ожидания окончания записи закончилось?
    447                  else if (GetTimerPointer() -> IsOverflow())
   \                     ??Fsm_10:
   \   00000086   ........           CALL    ??GetTimerPointer
   \   0000008A   ........           CALL    ??IsOverflow
   \   0000008E   2300               TST     R16
   \   00000090   F031               BREQ    ??Fsm_11
    448                  {
    449                      SetFsmEvent(WRITE_ERROR_FSM_EVENT);
   \   00000092   E004               LDI     R16, 4
   \   00000094   ........           CALL    ??SetFsmEvent
    450                      SetFsmState(IDDLE);
   \   00000098   E000               LDI     R16, 0
   \   0000009A   ........           CALL    ??SetFsmState
    451                  }
    452                  break;
   \                     ??Fsm_11:
   \   0000009E   9508               RET
    453          
    454          
    455              // Запись служеьного блока.
    456              case START_WRITE_BLOCKS_CONTROL_DATA:
    457                  // Данные обновлены.
    458                  // Сохраним изменённый служебный контекст.
    459                  if (Write(reinterpret_cast<uint8_t*>(&m_xBlocksControlData),
    460                            sizeof(m_xBlocksControlData),
    461                            BLOCKS_CONTROL_DATA))
   \                     ??Fsm_5:
   \   000000A0   E040               LDI     R20, 0
   \   000000A2   E62C               LDI     R18, 108
   \   000000A4   E030               LDI     R19, 0
   \   000000A6   ....               LDI     R16, LOW(??m_xBlocksControlData)
   \   000000A8   ....               LDI     R17, (??m_xBlocksControlData) >> 8
   \   000000AA   ....               RCALL   ??Write
   \   000000AC   2B01               OR      R16, R17
   \   000000AE   F051               BREQ    ??Fsm_12
    462                  {
    463                      // Установим время ожидания готовности к записи.
    464                      GetTimerPointer() -> Set(READY_TO_WRITE_WAITING_TIMEOUT);
   \   000000B0   ........           CALL    ??GetTimerPointer
   \   000000B4   EC28               LDI     R18, 200
   \   000000B6   E030               LDI     R19, 0
   \   000000B8   ........           CALL    ??Set
    465                      SetFsmState(READY_TO_WRITE_WAITING_BLOCKS_CONTROL_DATA);
   \   000000BC   E005               LDI     R16, 5
   \   000000BE   ........           CALL    ??SetFsmState
   \   000000C2   9508               RET
    466                  }
    467                  else
    468                  {
    469                      SetFsmEvent(WRITE_ERROR_FSM_EVENT);
   \                     ??Fsm_12:
   \   000000C4   E004               LDI     R16, 4
   \   000000C6   ........           CALL    ??SetFsmEvent
    470                      SetFsmState(IDDLE);
   \   000000CA   E000               LDI     R16, 0
   \   000000CC   ........           CALL    ??SetFsmState
    471                  }
    472                  break;
   \   000000D0   9508               RET
    473          
    474              case READY_TO_WRITE_WAITING_BLOCKS_CONTROL_DATA:
    475                  if (CEeprom::IsReadyToWrite())
   \                     ??Fsm_6:
   \   000000D2   ........           CALL    ??IsReadyToWrite
   \   000000D6   2300               TST     R16
   \   000000D8   F061               BREQ    ??Fsm_13
    476                  {
    477                      // Установим время ожидания окончания записи.
    478                      GetTimerPointer() -> Set(WRITE_END_WAITING_TIMEOUT);
   \   000000DA   ........           CALL    ??GetTimerPointer
   \   000000DE   E120               LDI     R18, 16
   \   000000E0   E237               LDI     R19, 39
   \   000000E2   ........           CALL    ??Set
    479                      CEeprom::StartWrite();
   \   000000E6   ........           CALL    ??StartWrite
    480                      SetFsmState(WRITE_END_WAITING_BLOCKS_CONTROL_DATA);
   \   000000EA   E006               LDI     R16, 6
   \   000000EC   ........           CALL    ??SetFsmState
   \   000000F0   9508               RET
    481                  }
    482                  // Время ожидания готовности к записи закончилось?
    483                  else if (GetTimerPointer() -> IsOverflow())
   \                     ??Fsm_13:
   \   000000F2   ........           CALL    ??GetTimerPointer
   \   000000F6   ........           CALL    ??IsOverflow
   \   000000FA   2300               TST     R16
   \   000000FC   F0F1               BREQ    ??Fsm_14
    484                  {
    485                      SetFsmEvent(WRITE_ERROR_FSM_EVENT);
   \   000000FE   E004               LDI     R16, 4
   \   00000100   ........           CALL    ??SetFsmEvent
    486                      SetFsmState(IDDLE);
   \   00000104   E000               LDI     R16, 0
   \   00000106   ........           CALL    ??SetFsmState
    487                  }
    488                  break;
   \   0000010A   9508               RET
    489          
    490              case WRITE_END_WAITING_BLOCKS_CONTROL_DATA:
    491                  if (CEeprom::GetBufferIsWrited())
   \                     ??Fsm_7:
   \   0000010C   ........           CALL    ??GetBufferIsWrited
   \   00000110   2300               TST     R16
   \   00000112   F039               BREQ    ??Fsm_15
    492                  {
    493                      SetFsmEvent(WRITE_OK_FSM_EVENT);
   \   00000114   E003               LDI     R16, 3
   \   00000116   ........           CALL    ??SetFsmEvent
    494                      SetFsmState(IDDLE);
   \   0000011A   E000               LDI     R16, 0
   \   0000011C   ........           CALL    ??SetFsmState
   \   00000120   9508               RET
    495                  }
    496                  // Время ожидания окончания записи закончилось?
    497                  else if (GetTimerPointer() -> IsOverflow())
   \                     ??Fsm_15:
   \   00000122   ........           CALL    ??GetTimerPointer
   \   00000126   ........           CALL    ??IsOverflow
   \   0000012A   2300               TST     R16
   \   0000012C   F031               BREQ    ??Fsm_14
    498                  {
    499                      SetFsmEvent(WRITE_ERROR_FSM_EVENT);
   \   0000012E   E004               LDI     R16, 4
   \   00000130   ........           CALL    ??SetFsmEvent
    500                      SetFsmState(IDDLE);
   \   00000134   E000               LDI     R16, 0
   \   00000136   ........           CALL    ??SetFsmState
    501                  }
    502                  break;
    503          
    504              default:
    505                  break;
    506              }
    507          }
   \                     ??Fsm_14:
   \   0000013A   9508               RET
    508          
    509          //-----------------------------------------------------------------------------------------------------
    510          
    511          
    512          
    513          
    514          
    515          
    516          
    517          
    518          //-----------------------------------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    519          uint16_t CDataStore::ReadBlockFlash(uint8_t *puiDestination, uint8_t uiBlock)
   \                     ??ReadBlockFlash:
    520          {
   \   00000000   ........           CALL    ?PROLOGUE3_L09
   \   00000004   01C8               MOVW    R25:R24, R17:R16
   \   00000006   2FA2               MOV     R26, R18
    521              return CFlash::ReadBlock(puiDestination, uiBlock);
   \   00000008   2F2A               MOV     R18, R26
   \   0000000A   018C               MOVW    R17:R16, R25:R24
   \   0000000C   ........           CALL    ??ReadBlock_6
   \   00000010   E0E3               LDI     R30, 3
   \   00000012   ........           JMP     ?EPILOGUE_B3_L09
    522          }

   \                                 In  segment NEAR_ID, align 1, keep-with-next, root
   \                     `?<Initializer for >`:
   \   00000000   ............       DC16 ?_1, ??m_xTimer, `?<Unnamed 0>`/2

   \                                 In  segment DIFUNCT, align 1, keep-with-next, root
   \   00000000                      REQUIRE ?call_ctors
   \   00000000   ....               DW      ??__sti__routine/2

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      2      2   <Unnamed 0>
        2      2   -> CTimer::~CTimer()
      4      2   CDataStore::Check()
        4      2   -> CDataStore::Fsm()
        4      2   -> CDataStore::GetFsmEvent()
        4      2   -> CDataStore::Init()
        4      2   -> CDataStore::ReadBlock(uint8_t *, uint8_t)
        4      2   -> CDataStore::WriteBlock(uint8_t *, uint16_t, uint8_t)
        4      2   -> CHammingCodes::GetErrorCode()
        4      2   -> CHammingCodes::SetErrorCode(uint8_t)
        4      2   -> CPlatform::WatchdogReset()
        4      2   -> delay_ms(uint16_t)
      0      2   CDataStore::CompareCurrentWithStoredCrc()
        0      2 ?S_EC_MUL_L02
     26      2   CDataStore::CrcOfBlocksCrcCheck()
       26      2   -> usCrc16(unsigned char const *, uint16_t)
       26      2 ?S_EC_MUL_L02
     26      2   CDataStore::CrcOfBlocksCrcCreate()
       26      2   -> usCrc16(unsigned char const *, uint16_t)
       26      2 ?S_EC_MUL_L02
      0      2   CDataStore::Fsm()
        0      2   -> CDataStore::GetFsmState()
        0      2   -> CDataStore::GetTimerPointer()
        0      2   -> CDataStore::SetFsmEvent(uint8_t)
        0      2   -> CDataStore::SetFsmState(uint8_t)
        0      2   -> CDataStore::Write(uint8_t *, uint16_t, uint8_t)
        0      2   -> CEeprom::GetBufferIsWrited()
        0      2   -> CEeprom::IsReadyToWrite()
        0      2   -> CEeprom::StartWrite()
        0      2   -> CTimer::IsOverflow()
        0      2   -> CTimer::Set(uint16_t)
      0      2   CDataStore::GetFsmEvent()
      0      2   CDataStore::GetFsmState()
      0      2   CDataStore::GetTimerPointer()
      0      2   CDataStore::Init()
        0      2   -> CDataStore::SetFsmState(uint8_t)
        0      2   -> CHammingCodes::CalculateEncodedDataLength(uint16_t)
        0      2   -> memset
    270      2   CDataStore::ReadBlock(uint8_t *, uint8_t)
      270      2   -> CEeprom::Read(uint8_t *, uint16_t, uint16_t)
      270      2   -> CHammingCodes::HammingCodesToBytes(uint8_t *, uint8_t *, uint16_t)
      270      2   -> CPss21::SetErrorCode(uint8_t)
      270      2   -> memcpy
      270      2   -> usCrc16(unsigned char const *, uint16_t)
      270      2 ?S_EC_MUL_L02
      3      2   CDataStore::ReadBlockFlash(uint8_t *, uint8_t)
        3      2   -> CFlash::ReadBlock(uint8_t *, uint8_t)
      0      2   CDataStore::SetFsmEvent(uint8_t)
      0      2   CDataStore::SetFsmState(uint8_t)
    266      2   CDataStore::Write(uint8_t *, uint16_t, uint8_t)
      266      2   -> CEeprom::WriteInterrupt(uint16_t, uint8_t *, uint16_t)
      266      2   -> CHammingCodes::BytesToHammingCodes(uint8_t *, uint8_t *, uint16_t)
      266      2   -> memcpy
      266      2   -> usCrc16(unsigned char const *, uint16_t)
      266      2 ?S_EC_MUL_L02
      5      2   CDataStore::WriteBlock(uint8_t *, uint16_t, uint8_t)
        5      2   -> CDataStore::GetFsmState()
        5      2   -> CDataStore::SetFsmEvent(uint8_t)
        5      2   -> CDataStore::SetFsmState(uint8_t)
        5      2   -> CDataStore::Write(uint8_t *, uint16_t, uint8_t)
      0      2   CEeprom::GetBufferIsWrited()
      0      2   CEeprom::IsReadyToWrite()
      0      2   CEeprom::ReadyInterruptEnable()
      0      2   CEeprom::SetBufferIsWrited(bool)
      0      2   CEeprom::StartWrite()
        0      2   -> CEeprom::ReadyInterruptEnable()
        0      2   -> CEeprom::SetBufferIsWrited(bool)
      0      2   CHammingCodes::GetErrorCode()
      0      2   CHammingCodes::SetErrorCode(uint8_t)
      0      2   CPlatform::WatchdogReset()
      0      2   CPss21::SetErrorCode(uint8_t)
      0      2   __sti__routine()
        0      2   -> CTimer::CTimer()
        0      2   -> __record_needed_destruction


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       6  ?<Initializer for >
      22  ?<Unnamed 0>
     202  CDataStore::Check()
      74  CDataStore::CompareCurrentWithStoredCrc()
     100  CDataStore::CrcOfBlocksCrcCheck()
      88  CDataStore::CrcOfBlocksCrcCreate()
     316  CDataStore::Fsm()
       6  CDataStore::GetFsmEvent()
       6  CDataStore::GetFsmState()
       6  CDataStore::GetTimerPointer()
     108  CDataStore::Init()
     268  CDataStore::ReadBlock(uint8_t *, uint8_t)
      22  CDataStore::ReadBlockFlash(uint8_t *, uint8_t)
       6  CDataStore::SetFsmEvent(uint8_t)
       6  CDataStore::SetFsmState(uint8_t)
     278  CDataStore::Write(uint8_t *, uint16_t, uint8_t)
      70  CDataStore::WriteBlock(uint8_t *, uint16_t, uint8_t)
      26  CDataStore::m_auiBlocksCurrentCrc
       2  CDataStore::m_puiIntermediateBuff
       1  CDataStore::m_uiFsmEvent
       1  CDataStore::m_uiFsmState
     108  CDataStore::m_xBlocksControlData
       6  CDataStore::m_xTimer
       6  CEeprom::GetBufferIsWrited()
      12  CEeprom::IsReadyToWrite()
       4  CEeprom::ReadyInterruptEnable()
       6  CEeprom::SetBufferIsWrited(bool)
      12  CEeprom::StartWrite()
       6  CHammingCodes::GetErrorCode()
       6  CHammingCodes::SetErrorCode(uint8_t)
       4  CPlatform::WatchdogReset()
       6  CPss21::SetErrorCode(uint8_t)
       1  _A_ACSR
       2  _A_ADC
       1  _A_ADCSRA
       1  _A_ADMUX
       1  _A_ASSR
       1  _A_DDRA
       1  _A_DDRB
       1  _A_DDRC
       1  _A_DDRD
       1  _A_DDRE
       1  _A_DDRF
       1  _A_DDRG
       2  _A_EEAR
       1  _A_EECR
       1  _A_EEDR
       1  _A_EICRA
       1  _A_EICRB
       1  _A_EIFR
       1  _A_EIMSK
       1  _A_ETIFR
       1  _A_ETIMSK
       2  _A_ICR1
       2  _A_ICR3
       1  _A_MCUCR
       1  _A_MCUCSR
       1  _A_OCDR
       1  _A_OCR0
       2  _A_OCR1A
       2  _A_OCR1B
       2  _A_OCR1C
       1  _A_OCR2
       2  _A_OCR3A
       2  _A_OCR3B
       2  _A_OCR3C
       1  _A_OSCCAL
       1  _A_PINA
       1  _A_PINB
       1  _A_PINC
       1  _A_PIND
       1  _A_PINE
       1  _A_PINF
       1  _A_PING
       1  _A_PORTA
       1  _A_PORTB
       1  _A_PORTC
       1  _A_PORTD
       1  _A_PORTE
       1  _A_PORTF
       1  _A_PORTG
       1  _A_RAMPZ
       1  _A_SFIOR
       2  _A_SP
       1  _A_SPCR
       1  _A_SPDR
       1  _A_SPMCSR
       1  _A_SPSR
       1  _A_SREG
       1  _A_TCCR0
       1  _A_TCCR1A
       1  _A_TCCR1B
       1  _A_TCCR1C
       1  _A_TCCR2
       1  _A_TCCR3A
       1  _A_TCCR3B
       1  _A_TCCR3C
       1  _A_TCNT0
       2  _A_TCNT1
       1  _A_TCNT2
       2  _A_TCNT3
       1  _A_TIFR
       1  _A_TIMSK
       1  _A_TWAR
       1  _A_TWBR
       1  _A_TWCR
       1  _A_TWDR
       1  _A_TWSR
       1  _A_UBRR0H
       1  _A_UBRR0L
       1  _A_UBRR1H
       1  _A_UBRR1L
       1  _A_UCSR0A
       1  _A_UCSR0B
       1  _A_UCSR0C
       1  _A_UCSR1A
       1  _A_UCSR1B
       1  _A_UCSR1C
       1  _A_UDR0
       1  _A_UDR1
       1  _A_WDTCR
       1  _A_XDIV
       1  _A_XMCRA
       1  _A_XMCRB
      18  __sti__routine()
      46  -- Other

 
   105 bytes in segment ABSOLUTE
 1 658 bytes in segment CODE
     2 bytes in segment DIFUNCT
    14 bytes in segment INITTAB
    22 bytes in segment NEAR_F
     6 bytes in segment NEAR_I
     6 bytes in segment NEAR_ID
   146 bytes in segment NEAR_Z
 
 1 596 bytes of CODE memory (+ 106 bytes shared)
   152 bytes of DATA memory (+ 105 bytes shared)

Errors: none
Warnings: 7
